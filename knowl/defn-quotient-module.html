<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<section class="paragraphs"><h4 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> – Quotient Module.</span></h4> <div class="para logical">
<div class="para">Let <span class="process-math">\(R\)</span> be a ring, let <span class="process-math">\(M\)</span> be an R-module, and let <span class="process-math">\(N\)</span> be a submodule of <span class="process-math">\(M\text{.}\)</span> The <em class="emphasis"><span class="process-math">\(\defnn{quotient module}\)</span></em> <span class="process-math">\(M/N\)</span> is the quotient group <span class="process-math">\(M/N\)</span> under <span class="process-math">\(+\)</span> (so elements of <span class="process-math">\(M/N\)</span> are additive cosets of the form <span class="process-math">\(m + N\)</span> with <span class="process-math">\(m \in M\)</span> and addition is defined by <span class="process-math">\((m_1 + N) + (m_2 + N) = (m_1+m_2) + N\)</span>) and with the rule for scaling by <span class="process-math">\(R\)</span> defined to be</div>
<div class="displaymath process-math">
\begin{equation*}
r \cdot (m + N) = rm + N
\end{equation*}
</div>
<div class="para">for all <span class="process-math">\(r \in R\)</span> and <span class="process-math">\(m + N \in M/N\text{.}\)</span>
</div>
</div> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\lem\)</span> – Quotient Map is <span class="process-math">\(R\)</span>-module Homomorphism.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring, let <span class="process-math">\(M\)</span> be an <span class="process-math">\(R\)</span>-module, and let <span class="process-math">\(N\)</span> be a submodule of <span class="process-math">\(M\text{.}\)</span> The rule for scaling introduced above is well-defined and it, along with the rule for <span class="process-math">\(+\text{,}\)</span> makes <span class="process-math">\(M/N\)</span> into an <span class="process-math">\(R\)</span>-module. Moreover, the canonical quotient map <span class="process-math">\(\pi: M \to M/N\text{,}\)</span> defined by <span class="process-math">\(\pi(m) = m + N\text{,}\)</span> is an <span class="process-math">\(R\)</span>-module homomorphism whose kernel is <span class="process-math">\(\ker(\pi) = N\text{.}\)</span>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">Among the many things to check here, we will only check a couple.</div> <div class="para">We need to prove the rule for scaling by <span class="process-math">\(R\)</span> on <span class="process-math">\(M/N\)</span> is well-defined: If <span class="process-math">\(m+N=m'+N\)</span> then <span class="process-math">\(m-m'\in N\)</span> so <span class="process-math">\(r(m-m')\in N\)</span> by the definition of submodule. This gives that <span class="process-math">\(rm-rm'\in N\text{,}\)</span> hence <span class="process-math">\(rm+N=rm'+N\text{.}\)</span> The module axioms are then pretty straightforward. We already know from 817 that <span class="process-math">\(M/N\)</span> is an abelian group under <span class="process-math">\(+\text{.}\)</span>
</div> <div class="para logical">
<div class="para">Let us check one of the four axioms involving scaling. We have</div>
<div class="displaymath process-math">
\begin{equation*}
r( (m_1 +N) + (m_2 +N)) = r((m_1 + m_2) + N) = (r(m_1+m_2)) + N = (rm_1 + rm_2) + N = (rm_1 + N) + (rm_2 + N),
\end{equation*}
</div>
<div class="para">which gives the third such axiom. The other three are also straightforward.</div>
</div> <div class="para">The fact that <span class="process-math">\(\pi\)</span> is an <span class="process-math">\(R\)</span>-module homomorphism is also straightforward. Its kernel is <span class="process-math">\(\{m \in M \mid m + N = N\}\text{,}\)</span> which is equal to <span class="process-math">\(N\text{.}\)</span>
</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> – <span class="process-math">\(\Z\)</span>-modules and Quotients.</span></h5> <div class="para">Recall that <span class="process-math">\(\Z\)</span>-module are the same as abelian groups. submodules and quotient <span class="process-math">\(\Z\)</span>-modules are the same things as subgroups and quotients of abelian groups.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\thm\)</span> – Module Isomorphism Theorems.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(R\)</span> be a ring, and let <span class="process-math">\(M\)</span> be a <span class="process-math">\(R\)</span>-module. - (UMP for Quotient Modules) Let <span class="process-math">\(N\)</span> be a submodule of <span class="process-math">\(M\text{,}\)</span> let <span class="process-math">\(T\)</span> be an <span class="process-math">\(R\)</span>-module, and let <span class="process-math">\(f: M \to T\)</span> be an <span class="process-math">\(R\)</span>-module homomorphism. If <span class="process-math">\(f(M) = 0\)</span> (i.e., if <span class="process-math">\(N \subseteq \ker(f)\)</span>) then the function <span class="process-math">\(\ov{f}: M/N \to T\)</span> given by <span class="process-math">\(\ov{f}(m + N) = f(m)\)</span> is a well-defined, <span class="process-math">\(R\)</span>-module homomorphism. In fact, <span class="process-math">\(\ov{f}: M/N \to T\)</span> is the unique <span class="process-math">\(R\)</span>-module homomorphism such that <span class="process-math">\(\ov{f}\circ \can = f\)</span> where <span class="process-math">\(\can\)</span> denotes the canonical surjection <span class="process-math">\(M \onto M/N\text{.}\)</span>- (First Isomorphism Theorem) Let <span class="process-math">\(T\)</span> be an <span class="process-math">\(R\)</span>-module and let <span class="process-math">\(h: M \to T\)</span> be an <span class="process-math">\(R\)</span>-module homomorphism. Then <span class="process-math">\(\ker(h)\)</span> is a submodule of <span class="process-math">\(M\)</span> and there is an <span class="process-math">\(R\)</span>-module isomorphism <span class="process-math">\(M/\ker(h) \cong \im(h)\)</span> given by <span class="process-math">\(m + \ker(h) \mapsto h(m)\text{.}\)</span> - (Second Isomorphism Theorem) Let <span class="process-math">\(A\)</span> and <span class="process-math">\(B\)</span> be submodules of <span class="process-math">\(M\text{,}\)</span> and define <span class="process-math">\(A + B = \{a+b \mid a \in A, b \in B\}\text{.}\)</span> Then <span class="process-math">\(A + B\)</span> is a submodule of <span class="process-math">\(M\text{,}\)</span> <span class="process-math">\(A \cap B\)</span> is a submodule of <span class="process-math">\(A\text{,}\)</span> and there is an <span class="process-math">\(R\)</span>-module isomorphism <span class="process-math">\((A + B)/B \cong A/(A \cap B)\text{.}\)</span> - (Third Isomorphism Theorem) Let <span class="process-math">\(A\)</span> and <span class="process-math">\(B\)</span> be submodules of <span class="process-math">\(M\)</span> with <span class="process-math">\(A \subseteq B\text{.}\)</span> Then <span class="process-math">\(B/A\)</span> is a submodule of <span class="process-math">\(M/A\)</span> and there is an <span class="process-math">\(R\)</span>-module isomorphism <span class="process-math">\((M/A)/(B/A) \cong M/B\)</span> given by sending <span class="process-math">\((m + A) + B/A\)</span> to <span class="process-math">\(m + B\text{.}\)</span> - (Lattice Isomorphism Theorem) Let <span class="process-math">\(R\)</span> be a ring, let <span class="process-math">\(N\)</span> be a R-submodule of <span class="process-math">\(M\text{,}\)</span> and let <span class="process-math">\(\pi: M \to M/N\)</span> be the canonical quotient map. Then the function</div>
<div class="displaymath process-math">
\begin{equation*}
\Psi : \{R-\text{submodules of } M \text{ containing }N\} \to \{R-\text{submodules of }M/N\}
\end{equation*}
</div>
<div class="para">defined by <span class="process-math">\(\Psi(K) = K/N\)</span> is a bijection, with inverse given by <span class="process-math">\(\Psi^{-1}(T) = \pi^{-1}(T)\)</span> for each <span class="process-math">\(R\)</span> submodule <span class="process-math">\(T\)</span> of <span class="process-math">\(M/N\text{.}\)</span> Moreover, <span class="process-math">\(\Psi\)</span> and <span class="process-math">\(\Psi^{-1}\)</span> preserve sums and intersections.</div>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">Ignoring the rules for scaling by <span class="process-math">\(R\text{,}\)</span> we know each of the frist four results holds for abelian groups (and the maps are the same). So, we merely need to prove that the rules for scaling are respected in each case. In more detail:</div> <div class="para logical">
<div class="para">For the UMP, we already know that <span class="process-math">\(\ov{f}\)</span> is a well-defined homomorphism of groups under <span class="process-math">\(+\)</span> and that it is the unique one such that <span class="process-math">\(\ov{f} \circ \can = f\text{.}\)</span> It remains only to show <span class="process-math">\(\ov{f}\)</span> preserves scaling: This follows quickly from the definitions:</div>
<div class="displaymath process-math">
\begin{equation*}
\ov{f}(r (m +N)) = \ov{f} (rm + N) = f(rm) = r f(m) = r \ov{f}(m + N).
\end{equation*}
</div>
<div class="para">where the third equation uses that <span class="process-math">\(f\)</span> preserves scaling.</div>
</div> <div class="para logical">
<div class="para">For the First Isomorphism Theorem, we already know that there is an isomorphism of abelian groups under <span class="process-math">\(+\text{,}\)</span>
</div>
<div class="displaymath process-math">
\begin{equation*}
\ov{h}: M/\ker(h) \xra{\cong} \im(h),
\end{equation*}
</div>
<div class="para">given by <span class="process-math">\(\ov{h}(m + \ker(h)) = h(m)\text{,}\)</span> and it remains only to show this map preserves scaling. This is a special case of what we proved in part (0).</div>
</div> <div class="para logical">
<div class="para">For the second isomorphism theorem, we need to first check that <span class="process-math">\(A+B\)</span> and <span class="process-math">\(A \cap B\)</span> are submodules. From 817 we already know they are subgroups under <span class="process-math">\(+\text{,}\)</span> and it is evident from the definitions that each is closed under scaling by elements of <span class="process-math">\(R\text{.}\)</span> Now, we know from 817 that there is an isomorphism of abelian groups <span class="process-math">\(h: A/(A \cap B) \xra{\cong} (A+B)/B\)</span> given by <span class="process-math">\(h(a + (A\cap B)) = a + B\text{.}\)</span> It remains only to show <span class="process-math">\(h\)</span> preserves scaling:</div>
<div class="displaymath process-math">
\begin{equation*}
h(r(a+(A \cap B))) = h(ra + A \cap B) = ra + B = r(a +B) = rh(a + (A \cap B)).
\end{equation*}
</div>
</div> <div class="para">For the third, we already know (from 817) that <span class="process-math">\(B/A\)</span> is a subgroup of <span class="process-math">\(M/A\)</span> under <span class="process-math">\(+\text{.}\)</span> Given <span class="process-math">\(r \in R\)</span> and <span class="process-math">\(b +A \in B/A\)</span> we have <span class="process-math">\(r(b+A) = rb + A\)</span> which belongs to <span class="process-math">\(B/A\)</span> since <span class="process-math">\(rb \in B\text{.}\)</span> This proves <span class="process-math">\(B/A\)</span> is a submodule of <span class="process-math">\(M/A\text{.}\)</span> Also from 817 we know there is an isomorphism of abelian groups <span class="process-math">\(h: (M/A)/(B/A) \to M/B\)</span> given by <span class="process-math">\(h((m+A) + B/A) = m + B\)</span> and it remains only to show it is <span class="process-math">\(R\)</span>-linear: <span class="process-math">\(h(r((m+A) + B/A)) =h(r(m+A) + B/A) = h((rm + A) + B/A) = rm + B = r(m +B) = r h((m+A) + B/A)\text{.}\)</span>
</div> <div class="para">The Lattice Theorem is the most complicaed to gerenlize. From 817 we know thre is a bijection between the set of sub groups of <span class="process-math">\(M\)</span> and that contain <span class="process-math">\(N\)</span> and subgroups of the quotient group <span class="process-math">\(M/N\text{,}\)</span> and the maps are the same as given in the statment. We just need to prove that these maps send submodules to submodules. If <span class="process-math">\(K\)</span> is a submodule of <span class="process-math">\(M\)</span> containing <span class="process-math">\(N\text{,}\)</span> then by part (3) we know <span class="process-math">\(K/N\)</span> is a submodule of <span class="process-math">\(M/N\text{.}\)</span>
</div> <div class="para">If <span class="process-math">\(T\)</span> is a submodule of <span class="process-math">\(M/N\text{,}\)</span> then <span class="process-math">\(\pi^{-1}(T)\)</span> is an abelian group. For <span class="process-math">\(r \in R\)</span> adn <span class="process-math">\(m \in \pi^{-1}(T)\)</span> we have <span class="process-math">\(\pi(m) \in T\)</span> and hence <span class="process-math">\(\pi(rm) = r\pi(m) \in T\)</span> too, since <span class="process-math">\(T\)</span> is a submodule. This proves <span class="process-math">\(\pi^{-1}(T)\)</span> is a submodule.</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem 5 – Modules and Maximal Ideals.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a commutative ring (with <span class="process-math">\(1\)</span>)[^1] and let <span class="process-math">\(M\)</span> be an <span class="process-math">\(R\)</span>-module. Show that if <span class="process-math">\(M\neq 0\)</span> and the only submodules of <span class="process-math">\(M\)</span> are <span class="process-math">\(0\)</span> and <span class="process-math">\(M\text{,}\)</span> then there is a maximal ideal I of <span class="process-math">\(R\)</span> such that <span class="process-math">\(M\)</span> is isomorphic to <span class="process-math">\(R/I\)</span>[^2].</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof</em>..</span></h6> <div class="para">Let <span class="process-math">\(R\)</span> be a commutative ring (with <span class="process-math">\(1\)</span>) and let <span class="process-math">\(M\)</span> be an <span class="process-math">\(R\)</span>-module such that <span class="process-math">\(M\neq 0\)</span> and the only submodules of <span class="process-math">\(M\)</span> are <span class="process-math">\(0\)</span> and <span class="process-math">\(M\text{.}\)</span>
</div> <div class="para">As <span class="process-math">\(M\neq 0\text{,}\)</span> there exists a non-zero element <span class="process-math">\(m\in M\text{.}\)</span> Let <span class="process-math">\(f:R\to M\)</span> be defined by <span class="process-math">\(f(r)=rm\text{.}\)</span> Since <span class="process-math">\(1\in R\)</span> and <span class="process-math">\(1m=m\in Rm\text{,}\)</span> we have <span class="process-math">\(Rm=M\text{.}\)</span> By the First Isomorphism Theorem we see that <span class="process-math">\(R/\ker(f)\cong M\text{,}\)</span> making <span class="process-math">\(\ker(f)\)</span> an ideal in <span class="process-math">\(R\text{,}\)</span> which we shall conspicuously denote as <span class="process-math">\(I\)</span> henceforth. By the Lattice Isomorphism Theorem the only two ideals of <span class="process-math">\(R/I\)</span> are <span class="process-math">\(0\)</span> and <span class="process-math">\(R/I\text{,}\)</span> making <span class="process-math">\(R/I\)</span> a field, and <span class="process-math">\(I\)</span> a maximal ideal in <span class="process-math">\(R\text{.}\)</span>
</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring with <span class="process-math">\(0\neq 1\text{.}\)</span> Prove that if <span class="process-math">\(M\)</span> is an <span class="process-math">\(R\)</span>-module and <span class="process-math">\(N\)</span> is a submodule of <span class="process-math">\(M\)</span> such that <span class="process-math">\(N\)</span> and <span class="process-math">\(M/N\)</span> are finitely generated, then <span class="process-math">\(M\)</span> is finitely generated.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\prop\)</span> – Every Cyclic <span class="process-math">\(R\)</span>-module <span class="process-math">\(\cong\)</span> to <span class="process-math">\(R/I\)</span> for some <span class="process-math">\(I\)</span>.</span></h5> <div class="para">Every cyclic <span class="process-math">\(R\)</span>-module is isomorphic to <span class="process-math">\(R/I\)</span>[^1] for some left ideal <span class="process-math">\(I\text{.}\)</span>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para logical">
<div class="para">Say <span class="process-math">\(M\)</span> is cyclic and <span class="process-math">\(m \in M\)</span> is a generator of <span class="process-math">\(M\text{,}\)</span> so that <span class="process-math">\(M = \{rm \mid r \in R\}\text{.}\)</span> Define <span class="process-math">\(f: R \to M\)</span> to be the unique <span class="process-math">\(R\)</span>-map with <span class="process-math">\(f(1) = m\text{.}\)</span> Here I am applying the UMP for bases, using that <span class="process-math">\(\{1\}\)</span> is a basis of <span class="process-math">\(R\)</span> as a left <span class="process-math">\(R\)</span>-modules. More explicitly,</div>
<div class="displaymath process-math">
\begin{equation*}
f(r) = f(r\cdot 1) = r f(1) = rm
\end{equation*}
</div>
<div class="para">for all <span class="process-math">\(r \in R\text{.}\)</span> Then <span class="process-math">\(f\)</span> is onto, since <span class="process-math">\(m\)</span> generates <span class="process-math">\(M\text{.}\)</span> Its kernel is a left ideal <span class="process-math">\(I\)</span> of <span class="process-math">\(R\text{,}\)</span> since submodules of <span class="process-math">\(R\)</span> are the same thing as left ideals. By the FIT, there is an isomorphism <span class="process-math">\(R/I \xra{\cong} M\)</span> sending <span class="process-math">\(r + I\)</span> to <span class="process-math">\(rm\text{.}\)</span>
</div>
</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring. Recall that we proved in class that every cyclic <span class="process-math">\(R\)</span>-module is isomorphic to <span class="process-math">\(R/I\)</span> for some left ideal <span class="process-math">\(I\text{.}\)</span> Prove the left ideal <span class="process-math">\(I\)</span> occurring this statement is unique; that is, if a cyclic <span class="process-math">\(R\)</span>-module is isomorphic to <span class="process-math">\(R/I\)</span> and <span class="process-math">\(R/J\)</span> for left ideals <span class="process-math">\(I\)</span> and <span class="process-math">\(J\text{,}\)</span> then <span class="process-math">\(I = J\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\rem\)</span>.</span></h5> <div class="para">More generally, the same argument shows that if <span class="process-math">\(M\)</span> is a finitely generated <span class="process-math">\(R\)</span> module, say generated by <span class="process-math">\(n\)</span> elements, then <span class="process-math">\(M \cong R^n/N\)</span> for some submodule <span class="process-math">\(N\)</span> of <span class="process-math">\(R^n\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\lem\)</span> – <span class="process-math">\(M/IM\)</span> is an <span class="process-math">\(R/I\)</span>-module.</span></h5> <div class="para">For a commutative ring <span class="process-math">\(R\text{,}\)</span> module <span class="process-math">\(M\)</span> and ideal <span class="process-math">\(I\text{,}\)</span> the rules for addition in <span class="process-math">\(M/IM\)</span>[^1] and scaling by <span class="process-math">\(R/I\)</span> on <span class="process-math">\(M/IM\)</span> introduced above make <span class="process-math">\(M/IM\)</span> into an <span class="process-math">\(R/I\)</span>-module.</div> <div class="para">Moreover, given another <span class="process-math">\(R\)</span>-module <span class="process-math">\(N\)</span> and an <span class="process-math">\(R\)</span>-map <span class="process-math">\(f: M \to N\text{,}\)</span> the function <span class="process-math">\(\ov{f}: M/IM \to N/IN\)</span> given by <span class="process-math">\(\ov{f}(m + IM) = f(m) + IN\)</span> is a well-defined <span class="process-math">\(R/I\)</span>-module homomorphism.</div> <div class="para">Finally, if <span class="process-math">\(g: N \to P\)</span> is yet another <span class="process-math">\(R\)</span>-module homomorphism, then <span class="process-math">\(\ov{g} \circ \ov{f} = \ov{g \circ f}\text{,}\)</span> and we also have <span class="process-math">\(\ov{\id_M} = \id_{M/IM}\)</span> for any <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\text{.}\)</span>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">I leave some of the details as an exercise, but I will check a few of the necessary things:</div> <div class="para logical">
<div class="para">We already showed that the rule for scaling is well defined, and we know from 817 that the rule for addition is well-defined and that <span class="process-math">\((M/IM, +)\)</span> is an abelian group. To show <span class="process-math">\(M/IM\)</span> is an <span class="process-math">\(R/I\)</span>-module, there remain four axioms to verify. For instance,</div>
<div class="displaymath process-math">
\begin{equation*}
((r+I)(s+I))(m +IM) = (rs + I)(m + IM) = (rsm + IM) = (r+I)(sm +IM) = (r+I)((s+I)(m+IM)),
\end{equation*}
</div>
<div class="para">which verifies one of them; the other proofs are similar.</div>
</div> <div class="para logical">
<div class="para">Next, let me verify that the function <span class="process-math">\(\ov{f}\)</span> is a well-defined <span class="process-math">\(R/I\)</span>-map: Let <span class="process-math">\(g: M \to N/IN\)</span> be the composition of <span class="process-math">\(R\)</span>-maps <span class="process-math">\(M \xra{f} N \to N/IN\)</span> (the second one being the canonical one), so that <span class="process-math">\(g(m) = f(m) + IN\text{.}\)</span> Since <span class="process-math">\(f(\sum_i a_i m_i) = \sum a_i f(m_i) \in IN\)</span> for any <span class="process-math">\(a_i\)</span>’s belonging to <span class="process-math">\(I\)</span> and <span class="process-math">\(m_i\)</span>’s belonging to <span class="process-math">\(M\text{,}\)</span> we have <span class="process-math">\(IM \subseteq \ker(g)\text{.}\)</span> By the UMP for quotient modules, there is an induced <span class="process-math">\(R\)</span>-map <span class="process-math">\(\ov{f}: M/IM \to N/IN\)</span> given by <span class="process-math">\(\ov{f}(m + IM) = f(m) + IN\text{.}\)</span> The map <span class="process-math">\(\ov{f}\)</span> is so far only known to be an <span class="process-math">\(R\)</span>-map, but it is in fact an <span class="process-math">\(R/I\)</span>-map since</div>
<div class="displaymath process-math">
\begin{equation*}
\ov{f}((r + I)(m +IM)) =   \ov{f}(rm +IM) = f(rm) + IN = rf(m) + IN = (r+I)(f(m) + IN).
\end{equation*}
</div>
<div class="para">The final assertions are clear from the formula for <span class="process-math">\(\ov{f}\)</span> for an <span class="process-math">\(R\)</span>-map <span class="process-math">\(f\text{.}\)</span>
</div>
</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem 11 – Modules and <span class="process-math">\(m\leq n\)</span>.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a commutative ring with <span class="process-math">\(1\neq 0\text{,}\)</span> and let <span class="process-math">\(f : R^m\to R^n\)</span> be a surjective homomorphism of free <span class="process-math">\(R\)</span>-modules. Prove that <span class="process-math">\(m \leq n\text{.}\)</span>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">Let <span class="process-math">\(R^n=N\)</span> and <span class="process-math">\(R^m=M\text{.}\)</span>
</div> <div class="para">Let <span class="process-math">\(I\)</span> be a maximal ideal in <span class="process-math">\(R\text{.}\)</span> Thus <span class="process-math">\(R/I\)</span> is a field. Lemma 1.58 tells us that <span class="process-math">\(M/IM\)</span> and <span class="process-math">\(N/IN\)</span> are <span class="process-math">\(R/I\)</span>-vector spaces. Additionally, this gives rise to <span class="process-math">\(\overline{p}:M/IM\to N/IN\text{,}\)</span> which is a surjective <span class="process-math">\(R/I\)</span>-module linear transformation.</div> <div class="para">Note that <span class="process-math">\(M\)</span> is generated by <span class="process-math">\(e_i+IM\)</span> for <span class="process-math">\(i\leq m\text{.}\)</span> Let <span class="process-math">\(a_i\in R\)</span> and consider <span class="process-math">\(\sum a_ie_i=0\text{.}\)</span> For this to be <span class="process-math">\(0\)</span> we need it to be in <span class="process-math">\(IM\text{,}\)</span> and thus all <span class="process-math">\(a_i\in I\text{.}\)</span> So the set of <span class="process-math">\(e_i\)</span> is a basis for <span class="process-math">\(M/IM\)</span> with <span class="process-math">\(m\)</span> elements. Likewise <span class="process-math">\(N/IN\)</span> has a basis with <span class="process-math">\(n\)</span> elements. As we are surjective, Rank<span class="process-math">\(=n\text{,}\)</span> <span class="process-math">\(\dim=m\text{.}\)</span> So by Rank-Nullity <span class="process-math">\(\dim(\ker)=m-n\)</span> which is only positive with <span class="process-math">\(m\geq n\text{.}\)</span>
</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a non-zero commutative ring and suppose <span class="process-math">\(p: R^m \to R^n\)</span> is a surjective homomorphism of <span class="process-math">\(R\)</span>-modules for some non-negative integers <span class="process-math">\(m\)</span> and <span class="process-math">\(n\text{.}\)</span> 1. Prove that if <span class="process-math">\(R\)</span> is a field, then <span class="process-math">\(m \geq n\text{.}\)</span> 2. Prove that if <span class="process-math">\(R\)</span> is any non-zero commutative ring, then <span class="process-math">\(m \geq n\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem 5 – Showing Module is Torsion-Free.</span></h5> <div class="para logical">
<div class="para">Recall that a <span class="process-math">\(\Z\)</span>-module <span class="process-math">\(M\)</span> is called <em class="emphasis">torsion-free</em> if its torsion submodule is <span class="process-math">\(\Tor(M ) =\{0\},\)</span> where <span class="process-math">\(\Tor(M ) = \{m \in M | rm = 0 \text{ for some }r \in \Z\setminus\{0\}\}.\)</span> Consider the <span class="process-math">\(\Z\)</span>-module</div>
<div class="displaymath process-math">
\begin{equation*}
M= \frac{\Z \oplus \Z}{\langle(7, 11)\rangle }\text{ where }\langle(7, 11)\rangle = \{(7k, 11k) | k \in \Z\}.
\end{equation*}
</div>
<div class="para">Show that <span class="process-math">\(M\)</span> is torsion free.</div>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">Let <span class="process-math">\(m=(a,b)\in\Tor(M)\text{.}\)</span> Thus <span class="process-math">\(rm=0\)</span> for some nonzero <span class="process-math">\(r\in\Z\text{.}\)</span> Then <span class="process-math">\((ra,rb)=0\text{,}\)</span> and so <span class="process-math">\(ra=0\)</span> and <span class="process-math">\(rb=0\text{.}\)</span> Then there exists <span class="process-math">\(p,q\in\Z\)</span> such that <span class="process-math">\(7p=ra\)</span> and <span class="process-math">\(7q=rb\)</span> or <span class="process-math">\(11p=ra\)</span> and and <span class="process-math">\(11q=rb\text{.}\)</span> Notice that in <span class="process-math">\(M\)</span> we have <span class="process-math">\(7,11=0\text{,}\)</span> and thus neither <span class="process-math">\(7\)</span> nor <span class="process-math">\(11\)</span> can divide <span class="process-math">\(r\text{.}\)</span> Suppose <span class="process-math">\(7p=ra\)</span> and <span class="process-math">\(7q=rb\text{.}\)</span> As <span class="process-math">\(7\)</span> cannot divide <span class="process-math">\(r\)</span> we see that <span class="process-math">\(7\)</span> divides both <span class="process-math">\(a\)</span> and <span class="process-math">\(b\text{,}\)</span> placing them both <span class="process-math">\(\langle(7, 11)\rangle\text{.}\)</span> Thus <span class="process-math">\(m=0\text{.}\)</span> The same holds true if we use <span class="process-math">\(11\text{.}\)</span> Thus <span class="process-math">\(m=0\)</span> and <span class="process-math">\(\Tor(M)=\{0\}\text{.}\)</span>
</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\rem\)</span>.</span></h5> <div class="para">The Lemma shows that the rules <span class="process-math">\(M \mapsto M/IM\)</span> and <span class="process-math">\(f \mapsto \ov{f}\)</span> determine what is known as a functor from the category of <span class="process-math">\(R\)</span>-modules to the category of <span class="process-math">\(R/I\)</span>-modules.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> – Maximal Ideals and Vector Spaces.</span></h5> <div class="para">Suppose <span class="process-math">\(I\)</span> is a maximal ideal of a commutative ring <span class="process-math">\(R\text{.}\)</span> Then <span class="process-math">\(R/I\)</span>[^1] is a field,[^2] and given an <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\text{,}\)</span> <span class="process-math">\(M/IM\)</span> is a module over the field <span class="process-math">\(R/I\text{;}\)</span> i.e., it is a vector space over this field. Moreover, if <span class="process-math">\(f: M \to N\)</span> is an <span class="process-math">\(R\)</span>-map then <span class="process-math">\(\ov{f}: M/IM \to N/IN\)</span> is an <span class="process-math">\(R/I\)</span>-linear transformation.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring, let <span class="process-math">\(M\)</span> be a left <span class="process-math">\(R\)</span>-module and let <span class="process-math">\(N \subseteq M\)</span> be a left <span class="process-math">\(R\)</span>-submodule. 1. Prove that if <span class="process-math">\(M\)</span> is finitely generated (as an <span class="process-math">\(R\)</span>-module), then so is <span class="process-math">\(M/N\text{.}\)</span> 2. Prove that if <span class="process-math">\(M/N\)</span> and <span class="process-math">\(N\)</span> are both finitely generated, then so is <span class="process-math">\(M\text{.}\)</span> 3. Prove the converse to the previous part is false, as follows: Let <span class="process-math">\(F\)</span> be a field and <span class="process-math">\(R = F[x_1, x_2, \dots]\text{,}\)</span> the ring of polynomials in the infinite list of variables <span class="process-math">\(x_1, x_2, \dots\text{.}\)</span> (So, an element of <span class="process-math">\(R\)</span> is a {} <span class="process-math">\(F\)</span>-linear combination of monomials of the form <span class="process-math">\(x_1^{e_1} \cdots x_n^{e_n}\)</span> for <span class="process-math">\(n \geq 0\)</span> and <span class="process-math">\(e_i \geq 1\text{.}\)</span> Note that each element of <span class="process-math">\(R\)</span> involves only a finite number of variables, but there is no uniform bound on how many such variables can be involved in the elements of <span class="process-math">\(R\text{.}\)</span>) You may assume without proof that <span class="process-math">\(R\)</span> is a ring with the usual rules for adding and multiplying polynomials, which make sense since each element of <span class="process-math">\(R\)</span> involves only a finite number of variables. Finally let <span class="process-math">\(I\)</span> be the ideal of <span class="process-math">\(R\)</span> generated by the variables <span class="process-math">\(x_1, x_2, \dots\text{.}\)</span> Prove <span class="process-math">\(R\)</span> is finitely generated as an <span class="process-math">\(R\)</span>-module but the submodule <span class="process-math">\(I\)</span> is not.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring, <span class="process-math">\(M\)</span> and <span class="process-math">\(N\)</span> left <span class="process-math">\(R\)</span>-modules, and <span class="process-math">\(p: M \to N\)</span> an <span class="process-math">\(R\)</span>-module homomorphism. Assume that <span class="process-math">\(p\)</span> is surjective. We say <span class="process-math">\(p\)</span> is a {} if there exists an <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(j: N \to M\)</span> such that <span class="process-math">\(p \circ j = id_N\)</span> (i.e., <span class="process-math">\(p(j(n)) = n\)</span> for all <span class="process-math">\(n \in N\)</span>). 1. Prove that if <span class="process-math">\(N\)</span> is free, then every surjective <span class="process-math">\(R\)</span>-module homomorphism of the form <span class="process-math">\(p: M \to N\)</span> is a split surjection. 2. By giving an explicit example with justification, show the statement in part (a) would become false if <span class="process-math">\(N\)</span> were not assumed to be free.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para logical"><ol class="decimal">
<li><div class="para">Assume <span class="process-math">\(R\)</span> is a ring, <span class="process-math">\(W\)</span> an <span class="process-math">\(R\)</span>-module, and <span class="process-math">\(i: V \to W\)</span> an injective <span class="process-math">\(R\)</span>-module homomorphism. We say <span class="process-math">\(i\)</span> is a {} if there exists an <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(q: W \to V\)</span> such that <span class="process-math">\(q \circ i = id_V\)</span> (i.e., <span class="process-math">\(q(i(v)) = v\)</span> for all <span class="process-math">\(v \in V\)</span>).</div></li>
<li><div class="para">Prove that if <span class="process-math">\(R\)</span> is a field, <span class="process-math">\(V\)</span> is a subspace (i.e., submodule) of <span class="process-math">\(W\text{,}\)</span> and <span class="process-math">\(i\)</span> is the inclusion map, then <span class="process-math">\(i\)</span> is a split injection. Note that since <span class="process-math">\(i\)</span> is the inclusion map, what you need to prove is that there exists an <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(q: W \to V\)</span> such that <span class="process-math">\(q(v) = v\text{.}\)</span> {}: Start by picking a basis <span class="process-math">\(B\)</span> of <span class="process-math">\(V\)</span> and use a theorem proven in class to show that <span class="process-math">\(B\)</span> can be extended to a basis <span class="process-math">\(C\)</span> of <span class="process-math">\(W\text{.}\)</span> Use <span class="process-math">\(C\)</span> to construct <span class="process-math">\(q\text{.}\)</span> (I am assuming that <span class="process-math">\(V\)</span> is a subspace of <span class="process-math">\(W\)</span> and that <span class="process-math">\(i\)</span> is the inclusion map just for simplicity — more generally, it is true that every injective <span class="process-math">\(R\)</span>-module homomorphism is a split injection whenever <span class="process-math">\(R\)</span> is a field.)</div></li>
<li><div class="para">Assume <span class="process-math">\(R\)</span> is a non-zero integral domain, but that it is not a field. Prove there exists an <span class="process-math">\(R\)</span>-module homomorphism that is an injection but {} a split injection. {}: Pick <span class="process-math">\(a \in R\)</span> such that <span class="process-math">\(a \neq 0\)</span> and <span class="process-math">\(a\)</span> is not a unit, let <span class="process-math">\(I\)</span> be the proper ideal <span class="process-math">\(I = R \cdot a\)</span> generated by <span class="process-math">\(a\)</span> and show the inclusion map <span class="process-math">\(i: I \to R\)</span> is not a split injection.</div></li>
</ol></div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a commutative integral domain and <span class="process-math">\(M\)</span> an <span class="process-math">\(R\)</span>-module. A subset <span class="process-math">\(S\)</span> of <span class="process-math">\(M\)</span> is called a <em class="emphasis">maximal linearly independent</em> subset of <span class="process-math">\(M\)</span> if <span class="process-math">\(S\)</span> is linearly independent and any subset of <span class="process-math">\(M\)</span> properly containing <span class="process-math">\(S\)</span> is linearly dependent. 1. Let <span class="process-math">\(T\)</span> be a linearly independent subset of <span class="process-math">\(M\text{.}\)</span> Prove that <span class="process-math">\(T\)</span> is contained in some maximal linearly independent subset of <span class="process-math">\(M\text{.}\)</span> 2. Let <span class="process-math">\(T\)</span> be a linearly independent subset of <span class="process-math">\(M\)</span> and let <span class="process-math">\(N\)</span> be the <span class="process-math">\(R\)</span>-submodule of <span class="process-math">\(M\)</span> generated by <span class="process-math">\(T\text{.}\)</span> Prove that <span class="process-math">\(T\)</span> is a maximal linearly independent subset if and only if <span class="process-math">\(M/N\)</span> is torsion. (Recall that an <span class="process-math">\(R\)</span>-module <span class="process-math">\(P\)</span> is called “torsion’’ if for each <span class="process-math">\(p \in P\text{,}\)</span> there is a <span class="process-math">\(r \in R\)</span> such that <span class="process-math">\(r \ne 0\)</span> and <span class="process-math">\(rp = 0\text{.}\)</span>)</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para logical">
<div class="para">Prove that if <span class="process-math">\(R\)</span> is a commutative ring with <span class="process-math">\(1\neq 0\)</span> then <span class="process-math">\(R^m \cong R^n\)</span> as <span class="process-math">\(R\)</span>-modules if and only if <span class="process-math">\(m = n\text{.}\)</span> In order to do that, you will complete the following steps: 1. Show that if <span class="process-math">\(I\)</span> is any ideal of <span class="process-math">\(R\)</span> and <span class="process-math">\(M\)</span> is any <span class="process-math">\(R\)</span>-module, then <span class="process-math">\(M/IM\)</span> is an <span class="process-math">\(R/I\)</span>-module via</div>
<div class="displaymath process-math">
\begin{equation*}
(r + I) \cdot (m + IM) = rm + IM.
\end{equation*}
</div>
<div class="para">2. Show that if <span class="process-math">\(I\)</span> is any ideal of <span class="process-math">\(R\text{,}\)</span> then <span class="process-math">\(R^n/IR^n \cong (R/I)^n\)</span> as <span class="process-math">\(R/I\)</span>-modules. 3. Apply the previous part when <span class="process-math">\(I = \fm\)</span> is a maximal ideal of <span class="process-math">\(R\text{.}\)</span> You will need to use the following fact, which we shall prove in class very soon: if <span class="process-math">\(F\)</span> is a field, then <span class="process-math">\(F^n\cong F^m\)</span> as <span class="process-math">\(F\)</span>-vector spaces if and only if <span class="process-math">\(m=n\text{.}\)</span> #### Problem – Properties of Torsion Submodules Let <span class="process-math">\(R\)</span> be a domain and let <span class="process-math">\(M\)</span> be an <span class="process-math">\(R\)</span>-module. The torsion submodule of <span class="process-math">\(M\)</span> is</div>
<div class="displaymath process-math">
\begin{equation*}
\Tor(M) = \{m \in M \mid rm = 0 \text{ for some } r \in R \textrm{ with } r \neq 0 \}.
\end{equation*}
</div>
<div class="para">Elements of <span class="process-math">\(\Tor(M)\)</span> are called the torsion elements of <span class="process-math">\(M\text{,}\)</span> and the module <span class="process-math">\(M\)</span> is called {} if <span class="process-math">\(\Tor(M) = 0\text{.}\)</span> You may take for granted that this is actually a submodule of <span class="process-math">\(M\)</span> without proof. 1. Show that if <span class="process-math">\(M\)</span> and <span class="process-math">\(N\)</span> are <span class="process-math">\(R\)</span>-modules, then <span class="process-math">\(\Tor(M \oplus N) = \Tor(M) \oplus \Tor(N)\text{.}\)</span> 2. Show that if <span class="process-math">\(M \cong N\text{,}\)</span> then <span class="process-math">\(\Tor(M) \cong \Tor(N)\text{.}\)</span> 3. Show that if <span class="process-math">\(M\)</span> is a free <span class="process-math">\(R\)</span>-module then <span class="process-math">\(\Tor(M)=0\text{.}\)</span> 4. Show that if <span class="process-math">\(I\)</span> is an ideal of <span class="process-math">\(R\)</span> that is not principal, then <span class="process-math">\(I\)</span> is a torsion-free <span class="process-math">\(R\)</span>-module that is not a free <span class="process-math">\(R\)</span>-module. 5. Show that if <span class="process-math">\(I\neq(0)\)</span> is an ideal of <span class="process-math">\(R\)</span> then <span class="process-math">\(\Tor(R/I)=R/I\text{.}\)</span> 6. Suppose that R is a PID, and that <span class="process-math">\(M\)</span> is a finitely generated <span class="process-math">\(R\)</span>-module. Show that <span class="process-math">\(M\)</span> is a torsion-free <span class="process-math">\(R\)</span>-module if and only if <span class="process-math">\(M\)</span> is a free <span class="process-math">\(R\)</span>-module.</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(R\)</span> be a commutative ring with <span class="process-math">\(1 \neq 0\text{.}\)</span> Show that</div>
<div class="displaymath process-math">
\begin{equation*}
\ann_R (M \oplus N) = \ann_R (M) \cap \ann_R (N)
\end{equation*}
</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem 9 #unfinished.</span></h5> <div class="para">Let <span class="process-math">\(I\)</span> be an ideal in a commutative ring <span class="process-math">\(R\text{,}\)</span> let <span class="process-math">\(M\)</span> and <span class="process-math">\(N\)</span> be <span class="process-math">\(R\)</span>-modules and let <span class="process-math">\(f : M \to N\)</span> be an <span class="process-math">\(R\)</span>-module homomorphism.</div> <div class="para logical"><ol class="decimal">
<li><div class="para">Prove there is a unique <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(\ov{f} : M/IM \to N/IN\)</span> such that <span class="process-math">\(\ov{f} \circ p = q \circ f\text{,}\)</span> where <span class="process-math">\(p : M\to M/IM\)</span> and <span class="process-math">\(q : N\to N/IN\)</span> are the canonical quotient maps</div></li>
<li><div class="para">Prove that if <span class="process-math">\(I^2 = 0\)</span> and <span class="process-math">\(\ov{f}\)</span> is surjective, then so is <span class="process-math">\(f\)</span> . (Recall that <span class="process-math">\(I^2\)</span> is the idealgenerated by all elements of the form <span class="process-math">\(ab\text{,}\)</span> where <span class="process-math">\(a, b \in I\text{.}\)</span>)</div></li>
</ol></div></section></section><span class="incontext"><a href="sec-quote.html#defn-quotient-module" class="internal">in-context</a></span>
</body>
</html>
