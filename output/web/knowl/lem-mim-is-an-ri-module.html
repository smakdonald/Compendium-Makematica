<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\lem\)</span> – <span class="process-math">\(M/IM\)</span> is an <span class="process-math">\(R/I\)</span>-module.</span></h5> <div class="para">For a commutative ring <span class="process-math">\(R\text{,}\)</span> module <span class="process-math">\(M\)</span> and ideal <span class="process-math">\(I\text{,}\)</span> the rules for addition in <span class="process-math">\(M/IM\)</span>[^1] and scaling by <span class="process-math">\(R/I\)</span> on <span class="process-math">\(M/IM\)</span> introduced above make <span class="process-math">\(M/IM\)</span> into an <span class="process-math">\(R/I\)</span>-module.</div> <div class="para">Moreover, given another <span class="process-math">\(R\)</span>-module <span class="process-math">\(N\)</span> and an <span class="process-math">\(R\)</span>-map <span class="process-math">\(f: M \to N\text{,}\)</span> the function <span class="process-math">\(\ov{f}: M/IM \to N/IN\)</span> given by <span class="process-math">\(\ov{f}(m + IM) = f(m) + IN\)</span> is a well-defined <span class="process-math">\(R/I\)</span>-module homomorphism.</div> <div class="para">Finally, if <span class="process-math">\(g: N \to P\)</span> is yet another <span class="process-math">\(R\)</span>-module homomorphism, then <span class="process-math">\(\ov{g} \circ \ov{f} = \ov{g \circ f}\text{,}\)</span> and we also have <span class="process-math">\(\ov{\id_M} = \id_{M/IM}\)</span> for any <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\text{.}\)</span>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">I leave some of the details as an exercise, but I will check a few of the necessary things:</div> <div class="para logical">
<div class="para">We already showed that the rule for scaling is well defined, and we know from 817 that the rule for addition is well-defined and that <span class="process-math">\((M/IM, +)\)</span> is an abelian group. To show <span class="process-math">\(M/IM\)</span> is an <span class="process-math">\(R/I\)</span>-module, there remain four axioms to verify. For instance,</div>
<div class="displaymath process-math">
\begin{equation*}
((r+I)(s+I))(m +IM) = (rs + I)(m + IM) = (rsm + IM) = (r+I)(sm +IM) = (r+I)((s+I)(m+IM)),
\end{equation*}
</div>
<div class="para">which verifies one of them; the other proofs are similar.</div>
</div> <div class="para logical">
<div class="para">Next, let me verify that the function <span class="process-math">\(\ov{f}\)</span> is a well-defined <span class="process-math">\(R/I\)</span>-map: Let <span class="process-math">\(g: M \to N/IN\)</span> be the composition of <span class="process-math">\(R\)</span>-maps <span class="process-math">\(M \xra{f} N \to N/IN\)</span> (the second one being the canonical one), so that <span class="process-math">\(g(m) = f(m) + IN\text{.}\)</span> Since <span class="process-math">\(f(\sum_i a_i m_i) = \sum a_i f(m_i) \in IN\)</span> for any <span class="process-math">\(a_i\)</span>’s belonging to <span class="process-math">\(I\)</span> and <span class="process-math">\(m_i\)</span>’s belonging to <span class="process-math">\(M\text{,}\)</span> we have <span class="process-math">\(IM \subseteq \ker(g)\text{.}\)</span> By the UMP for quotient modules, there is an induced <span class="process-math">\(R\)</span>-map <span class="process-math">\(\ov{f}: M/IM \to N/IN\)</span> given by <span class="process-math">\(\ov{f}(m + IM) = f(m) + IN\text{.}\)</span> The map <span class="process-math">\(\ov{f}\)</span> is so far only known to be an <span class="process-math">\(R\)</span>-map, but it is in fact an <span class="process-math">\(R/I\)</span>-map since</div>
<div class="displaymath process-math">
\begin{equation*}
\ov{f}((r + I)(m +IM)) =   \ov{f}(rm +IM) = f(rm) + IN = rf(m) + IN = (r+I)(f(m) + IN).
\end{equation*}
</div>
<div class="para">The final assertions are clear from the formula for <span class="process-math">\(\ov{f}\)</span> for an <span class="process-math">\(R\)</span>-map <span class="process-math">\(f\text{.}\)</span>
</div>
</div></section></section><span class="incontext"><a href="sec-quote.html#lem-mim-is-an-ri-module" class="internal">in-context</a></span>
</body>
</html>
