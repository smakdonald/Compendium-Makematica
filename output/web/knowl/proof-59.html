<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="hiddenproof"><h2 class="heading"><span class="type">Proof</span></h2>
<div class="para">The equivalence of (3), (4), and (5) is given by the Splitting Theorem.</div> <div class="para logical">
<div class="para">
<span class="process-math">\((2) \Rightarrow (3)\)</span> holds since given an injective map <span class="process-math">\(i\)</span> as in (3), we have by (2) that <span class="process-math">\(i(M')\)</span> is a summand of <span class="process-math">\(M\text{,}\)</span> hence there is a projection homomorphism <span class="process-math">\(\pi:M\to i(M')\)</span> that splits the inclusion of the summand into <span class="process-math">\(M\text{,}\)</span> that is <span class="process-math">\(\pi|_{i(M')}=\mathrm{id}_{i(M')}\text{.}\)</span> Now <span class="process-math">\(i:M'\to i(M')\)</span> is an isomorphism so we may consider the <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(i^{-1}:i(M')\to M'\)</span> and set <span class="process-math">\(q:M\to M'\)</span> to be <span class="process-math">\(q=i^{-1}\circ \pi\text{.}\)</span> Then</div>
<div class="displaymath process-math">
\begin{equation*}
q\circ i=i^{-1}\circ \pi \circ i=i^{-1}\circ \pi_{i(M')} \circ i= i^{-1}\circ i=\mathrm{id}_{M'}.
\end{equation*}
</div>
</div> <div class="para logical">
<div class="para">
<span class="process-math">\((3) \Rightarrow (2)\)</span> holds since we can split the inclusion <span class="process-math">\(N\to M\)</span> and thus also the SES</div>
<div class="displaymath process-math">
\begin{equation*}
0\to N\to M\to M/N \to 0.
\end{equation*}
</div>
<div class="para">Therefore the Splitting Theorem yields <span class="process-math">\(M=N\oplus s(M/N)\)</span> where <span class="process-math">\(s\)</span> denotes the splitting of the quotient map <span class="process-math">\(M\to M/N\text{.}\)</span>
</div>
</div> <div class="para">The hard part is proving <span class="process-math">\((1) \Leftrightarrow (2)\text{.}\)</span> <span class="process-math">\((1) \Rightarrow (2)\)</span> Assume (1), so that <span class="process-math">\(M = \oplus_{\lambda \in \Lambda} M_\lambda\)</span> for some collection of simple submodules <span class="process-math">\(M_\lambda\text{,}\)</span> and let <span class="process-math">\(N \subseteq M\)</span> be any submodule. (It is important to note that it does not necessarily follow that <span class="process-math">\(N\)</span> is a sum of some subcollection of the <span class="process-math">\(M_\lambda\)</span>) . Consider the collection <span class="process-math">\(\mathcal S\)</span> of subsets <span class="process-math">\(\Gamma\)</span> of <span class="process-math">\(\Lambda\)</span> such that <span class="process-math">\(N \cap M_\Gamma = 0\)</span> where we define <span class="process-math">\(M_\Gamma := \oplus_{\lambda \in \Gamma} M_\lambda\text{.}\)</span> View <span class="process-math">\(\mathcal S\)</span> as a poset by inclusion. It is nonempty since <span class="process-math">\(J = \emptyset\)</span> belongs to <span class="process-math">\(\mathcal S\text{.}\)</span> If <span class="process-math">\(\{\Gamma_\alpha\}\)</span> is a totally ordered subcollection of <span class="process-math">\(\mathcal S\text{,}\)</span> let <span class="process-math">\(\Gamma = \cup_\alpha \Gamma_\alpha\text{.}\)</span> I claim <span class="process-math">\(M_\Gamma \cap N = 0\text{.}\)</span> If not, there is a nonzero element <span class="process-math">\((m_\gamma) \in M_\Gamma \cap N\text{.}\)</span> But since <span class="process-math">\(m_\gamma = 0\)</span> for all but a finite number of <span class="process-math">\(\gamma\)</span>’s and since the collection of <span class="process-math">\(\Gamma_\alpha\)</span>’s was totally ordered, there is some <span class="process-math">\(\alpha\)</span> such that <span class="process-math">\((m_\gamma) \in M_{\Gamma_\alpha} \cap N\text{,}\)</span> a contradiction. We may thus apply Zorn’s Lemma to get a maximal <span class="process-math">\(\Gamma \in \mathcal S\text{.}\)</span>
</div> <div class="para">I claim <span class="process-math">\(M\)</span> is the internal direct sum of <span class="process-math">\(N\)</span> and <span class="process-math">\(M_\Gamma\text{.}\)</span> We have <span class="process-math">\(N \cap M_\Gamma = 0\)</span> since <span class="process-math">\(\Gamma\in\mathcal S\)</span> and so it suffices to prove <span class="process-math">\(N + M_\Gamma = M\text{.}\)</span> Since <span class="process-math">\(M = \sum_{\lambda \in \Lambda} M_\lambda\text{,}\)</span> the latter is equivalent to proving that <span class="process-math">\(M_\lambda \subseteq N + M_\Gamma\)</span> for all <span class="process-math">\(\lambda \in \Lambda\text{.}\)</span> If this fails for some <span class="process-math">\(\lambda\text{,}\)</span> then since <span class="process-math">\(M_\lambda \cap (N + M_\Gamma)\)</span> is a proper submodule of <span class="process-math">\(M_\lambda\text{,}\)</span> which is simple, and hence <span class="process-math">\(M_\lambda \cap (N + M_\Gamma) = 0\text{.}\)</span> But then <span class="process-math">\(N \cap (M_{\Gamma} \oplus M_\lambda) = 0\)</span> (if <span class="process-math">\(n \in N\)</span> and <span class="process-math">\(n = m + m'\text{,}\)</span> with <span class="process-math">\(m\in M_\Gamma\)</span> and <span class="process-math">\(m'\in M_\lambda\text{,}\)</span> then <span class="process-math">\(m'=n-m\)</span> so <span class="process-math">\(m'=0\)</span> and <span class="process-math">\(n=m\text{,}\)</span> and then <span class="process-math">\(n=0\text{.}\)</span>) So, <span class="process-math">\(\Gamma\cup\{ \lambda\}\)</span> is a member of <span class="process-math">\(\mathcal S\)</span> that strictly contains <span class="process-math">\(\Gamma\text{,}\)</span> a contradiction. It must be thar <span class="process-math">\(M = N \oplus M_\Gamma\text{.}\)</span>
</div> <div class="para">
<span class="process-math">\((2) \Rightarrow (1)\)</span> Now assume that every submodule of <span class="process-math">\(M\)</span> is a summand. We proceed in three steps:</div> <div class="para">(i) We claim that every submodule <span class="process-math">\(T\)</span> of <span class="process-math">\(M\)</span> inherits this property; i.e., every submodule of <span class="process-math">\(T\)</span> is a summand of <span class="process-math">\(T\text{.}\)</span> For say <span class="process-math">\(U \subseteq T\)</span> is a submodule. By assumption on <span class="process-math">\(M\text{,}\)</span> we have <span class="process-math">\(M = U \oplus V\)</span> (internal direct sum) for some <span class="process-math">\(V\text{.}\)</span> Since <span class="process-math">\(U \subseteq T\text{,}\)</span> it follows that <span class="process-math">\(T = U + (V \cap T)\text{.}\)</span> (Given <span class="process-math">\(t \in T\text{,}\)</span> we have <span class="process-math">\(t  =  u +v\)</span> for some <span class="process-math">\(u \in U, v \in V\text{.}\)</span> Since <span class="process-math">\(U \subseteq T\text{,}\)</span> <span class="process-math">\(v =
t-u \in V \cap T\text{.}\)</span>) Since <span class="process-math">\(U \cap (V \cap T) = 0\text{,}\)</span> this shows <span class="process-math">\(T = U \oplus (V \cap T)\text{.}\)</span>
</div> <div class="para">(ii) We claim that every nonzero submodule <span class="process-math">\(T\)</span> of <span class="process-math">\(M\)</span> contains a simple summand. Pick <span class="process-math">\(0 \ne x \in T\)</span> and apply Zorn’s Lemma to show that there is a maximal submodule <span class="process-math">\(U\)</span> of <span class="process-math">\(T\)</span> with respect to the property that <span class="process-math">\(x \notin U\text{.}\)</span> We have <span class="process-math">\(T = U \oplus W\)</span> by (i) for some <span class="process-math">\(W \neq 0\text{.}\)</span> If <span class="process-math">\(W\)</span> is not simple, then <span class="process-math">\(W\)</span> contains a nonzero, proper submodule <span class="process-math">\(W_1\)</span> and hence, by using (i) again, we get that <span class="process-math">\(W = W_1 \oplus W_2\)</span> for some proper nonzero submodule <span class="process-math">\(W_2\text{.}\)</span>
</div> <div class="para">These properties implies that <span class="process-math">\((U \oplus W_1) \cap (U \oplus W_2) = U\text{.}\)</span> One containment is clear. If <span class="process-math">\(v\)</span> belongs to the left side, then <span class="process-math">\(v = u + w_1 = u' + w_2\text{.}\)</span> It follows that <span class="process-math">\(w_1 - w_2 = u - u' \in U \cap W = 0\)</span> and so <span class="process-math">\(w_1 = w_2 \in W_1 \cap W_2 = 0\text{,}\)</span> and hence <span class="process-math">\(w_1  = w_2 = 0\text{.}\)</span> So, either <span class="process-math">\(x \notin U \oplus W_1\)</span> or <span class="process-math">\(x \notin U \oplus W_2\text{,}\)</span> and either way we reach a contradiction to the maximality of <span class="process-math">\(U\text{.}\)</span>
</div> <div class="para logical">
<div class="para">(iii) Let <span class="process-math">\(\mathscr G\)</span> be the set of all simple submodules of <span class="process-math">\(M\text{,}\)</span> and let</div>
<div class="displaymath process-math">
\begin{equation*}
\mathscr  F= \{ \Omega \subseteq \mathscr G\ | \ \textrm{for all distinct} \ \omega_0, \omega_1, \dots, \omega_t \in \Omega, \omega_0 \cap (\omega_1 + \cdots + \omega_t) = 0\}.
\end{equation*}
</div>
<div class="para">Equivalently, the module generated by the modules in <span class="process-math">\(\Omega\)</span> their direct sum. The set <span class="process-math">\(\mathscr  F\)</span> is partially ordered by inclusion. It is nonempty, since <span class="process-math">\(\varnothing \in \mathscr  F\)</span> (or some singleton is in there by (ii)). Given a chain <span class="process-math">\(\{ \Omega_\alpha\}\)</span> in <span class="process-math">\(\mathscr  F\text{,}\)</span> <span class="process-math">\(\bigcup_\alpha \Omega_\alpha\)</span> is again an element of <span class="process-math">\(\mathscr  F\text{,}\)</span> so there is a maximal element in <span class="process-math">\(\mathscr  F\text{;}\)</span> call it <span class="process-math">\(\Omega\text{.}\)</span> Let <span class="process-math">\(U\)</span> be the direct sum of <span class="process-math">\(\Omega\text{.}\)</span>
</div>
</div> <div class="para">We claim that <span class="process-math">\(U=M\text{.}\)</span> By hypothesis we have <span class="process-math">\(M = U \oplus V\)</span> for some <span class="process-math">\(V\text{.}\)</span> If <span class="process-math">\(V = 0\)</span> we are done. Otherwise by (ii) (and (i) again) we have <span class="process-math">\(V = S \oplus V'\)</span> for some simple submodule <span class="process-math">\(S\text{.}\)</span> But then <span class="process-math">\(\Omega \cup \{ U\} \in \mathscr  F\text{,}\)</span> contradicting maximality of <span class="process-math">\(\Omega\text{.}\)</span>
</div></article><span class="incontext"><a href="ch-semisimple-mod.html#proof-59" class="internal">in-context</a></span>
</body>
</html>
