<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<section class="paragraphs"><h4 class="heading"><span class="title"><span class="process-math">\(\thm\)</span> - Smith Normal Form.</span></h4> <div class="para logical">
<div class="para">Let <span class="process-math">\(R\)</span> be a Euclidean domain and let <span class="process-math">\(A \in \Mat_{m \times n}(R)\text{.}\)</span> Then there is a sequence of elementary column and column operations that transform <span class="process-math">\(A\)</span> into a matrix <span class="process-math">\(S = [s_{i,j}]\)</span> such that all non-diagonal entries of <span class="process-math">\(S\)</span> are <span class="process-math">\(0\)</span> and the diagonal entries of <span class="process-math">\(S\)</span> satisfy</div>
<div class="displaymath process-math">
\begin{equation*}
s_{1,1} \mid s_{2,2} \mid s_{3,3} \mid \cdots.
\end{equation*}
</div>
<div class="para">###### <em class="emphasis">Proof.</em> The main point of the proof is to establish:</div>
</div> <div class="para logical">
<div class="para">{}: There is a sequence of row and column operations that transforms <span class="process-math">\(A\)</span> to</div>
<div class="displaymath process-math">
\begin{equation*}
A' = \begin{bmatrix}
g &amp; 0 \\
0 &amp; B \\
\end{bmatrix}
\end{equation*}
</div>
<div class="para">for some <span class="process-math">\((n-1) \times (m-1)\)</span> matrix <span class="process-math">\(B\)</span> and where <span class="process-math">\(g = \gcd(A)\text{.}\)</span> (We adopt the convention that if <span class="process-math">\(A\)</span> is the matrix of all <span class="process-math">\(0\)</span>'s, then <span class="process-math">\(g = 0\text{.}\)</span>) Note that, by Lemma , we have <span class="process-math">\(\gcd(A) = \gcd(A')\)</span> and thus <span class="process-math">\(g \mid \gcd(B)\text{.}\)</span>
</div>
</div> <div class="para logical">
<div class="para">Granting this claim, by applying it again to <span class="process-math">\(B\)</span> we arrive at a matrix of the form</div>
<div class="displaymath process-math">
\begin{equation*}
A'' = \begin{bmatrix}
g &amp; 0 &amp; 0\\
0 &amp; g' &amp; 0 \\
0 &amp; 0 &amp; C
\end{bmatrix}
\end{equation*}
</div>
<div class="para">where <span class="process-math">\(g' = \gcd(B)\)</span> and <span class="process-math">\(g \mid g'\)</span> and <span class="process-math">\(g' \mid \gcd(C)\text{.}\)</span> (Observe that the row and column operations on <span class="process-math">\(B\)</span> will not affect the first row and column of <span class="process-math">\(A'\text{.}\)</span>) Continuing in this fashion, we arrive at the matrix <span class="process-math">\(S\)</span> in the statement.</div>
</div> <div class="para">To prove the claim, let <span class="process-math">\(a\)</span> be the upper-left entry of <span class="process-math">\(A\text{.}\)</span>
</div> <div class="para">Suppose <span class="process-math">\(a\)</span> happens to be <span class="process-math">\(g = \gcd(A)\text{.}\)</span> Then, in particular, it divides every entry of the first row and column of <span class="process-math">\(A\text{,}\)</span> and so by doing row and column operations of type I, we may <span class="process-math">\(0\)</span> out these entries to arrive at a matrix of the desired form directly.</div> <div class="para">In general, let <span class="process-math">\(l\)</span> to be the number of prime factors in a prime factorization of of <span class="process-math">\(a/\gcd(A)\text{,}\)</span> and proceed by induction on <span class="process-math">\(l\text{.}\)</span>
</div> <div class="para">If <span class="process-math">\(l = 0\text{,}\)</span> then <span class="process-math">\(a = \gcd(A)\)</span> (up to associates), and we already did this case.</div> <div class="para">Assume <span class="process-math">\(l &gt; 0\text{.}\)</span> Then there is at least one entry <span class="process-math">\(b = a_{i,j}\)</span> such that <span class="process-math">\(a \nmid b\text{.}\)</span>
</div> <div class="para">Case I: There is such a <span class="process-math">\(b\)</span> belonging to the first row of <span class="process-math">\(A\text{.}\)</span> In this case we we may implement the Euclidean algorithm in the form of suitable column operations to replace <span class="process-math">\(a\)</span> by <span class="process-math">\(\gcd(a,b)\)</span> and <span class="process-math">\(b\)</span> by <span class="process-math">\(0\text{,}\)</span> as in the example above. Since <span class="process-math">\(a \nmid b\text{,}\)</span> <span class="process-math">\(\gcd(a,b)\)</span> is a proper divisor of <span class="process-math">\(a\text{,}\)</span> and it follows that the number of factors in a prime factorization of <span class="process-math">\(\gcd(a,b)/g\)</span> is smaller than <span class="process-math">\(l\text{,}\)</span> and we are done by induction.</div> <div class="para">Case II: There is such a <span class="process-math">\(b\)</span> in the first column. Just as in the previous case, we are done by induction upon implementing the Euclidean algorithm using suitable row operations.</div> <div class="para logical">
<div class="para">Case III: <span class="process-math">\(a\)</span> divides every entry of the first row and first column. In this case, suitable row and column operations transform <span class="process-math">\(A\)</span> to</div>
<div class="displaymath process-math">
\begin{equation*}
D = 
\begin{bmatrix}
a &amp; 0 \\
0 &amp; E \\
\end{bmatrix}.
\end{equation*}
</div>
<div class="para">By Lemma  we have <span class="process-math">\(\gcd(D) = \gcd(A)\text{,}\)</span> and thus there is some element <span class="process-math">\(e\)</span> of <span class="process-math">\(E\)</span> such that <span class="process-math">\(a \nmid e\)</span> (since we are assuming <span class="process-math">\(a\)</span> is not the gcd of <span class="process-math">\(A\)</span>). A suitable row operation puts <span class="process-math">\(e\)</span> into row one without affecting <span class="process-math">\(a\text{,}\)</span> and we are back to the previously solved Case I.</div>
</div> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\rem\)</span>.</span></h5> <div class="para">Note that some of the diagonal entries could be <span class="process-math">\(0\text{.}\)</span> Recall <span class="process-math">\(s \mid 0\)</span> for all <span class="process-math">\(s \in R\)</span> (including <span class="process-math">\(s = 0\)</span>), and <span class="process-math">\(0\)</span> is the only element that divides <span class="process-math">\(0\text{.}\)</span> So, the â€œtail'' end of the sequence could be all <span class="process-math">\(0\)</span>'s, and indeed if <span class="process-math">\(s_{i,i} = 0\)</span> for some <span class="process-math">\(i\)</span> then all subsequent diagonal entries must be <span class="process-math">\(0\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\cor\)</span> - FTFPMED: First Version.</span></h5> <div class="para logical">
<div class="para">If <span class="process-math">\(R\)</span> is a Euclidean domain and <span class="process-math">\(M\)</span> is a finitely presented <span class="process-math">\(R\)</span>-module, then <span class="process-math">\(M\)</span> is isomorphic to a direct sum of cyclic modules:</div>
<div class="displaymath process-math">
\begin{equation*}
M \cong R/d_1 \oplus \cdots \oplus R/d_l \oplus R^a
\end{equation*}
</div>
<div class="para">for some <span class="process-math">\(a \geq 0\)</span> and some non-zero, non-invertible elements <span class="process-math">\(d_1, \dots, d_l \in R\)</span> such that <span class="process-math">\(d_1 \mid d_2 \mid \cdots \mid d_l\text{.}\)</span>
</div>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">This is an immediate consequence of the SNF Theorem, Theorem  parts (1) and (2), and Lemma .</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> - Special Case of SNF.</span></h5> <div class="para">Suppose <span class="process-math">\(R\)</span> is a Euclidean domain and <span class="process-math">\(A = (x_1, \dots, x_n)\)</span> is a <span class="process-math">\(1 \times n\)</span> matrix. Column operations of type I in this case amount to adding a multiple of one element in this list to another one. The SNF Theorem in this case amounts to the Euclidean algorithm: By adding a suitable multiple of the one entry in the first two positions to the other, in the usual back-and-forth way, we arrive at <span class="process-math">\((g_1, 0, x_3, \dots, x_n)\)</span> where <span class="process-math">\(g_1 = \gcd(x_1, x_2)\text{.}\)</span> Repeat this for columns <span class="process-math">\(1\)</span> and <span class="process-math">\(3\)</span> to arrive at <span class="process-math">\((g_2, 0, 0, x_4, \dots, x_n)\)</span> where <span class="process-math">\(g_2 = \gcd(g_1, x_3) = \gcd(x_1, x_2, x_3)\text{.}\)</span> Continuing in this fashion we arrive at <span class="process-math">\((g, 0, \dots, 0)\)</span> where <span class="process-math">\(g = \gcd(x_1, \dots, x_n)\text{.}\)</span>
</div> <div class="para">The proof of the SNF Theorem in general amounts to an extended version of the idea used in this special case.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> - Finding SNF.</span></h5> <div class="para logical">
<div class="para">Consider the matrix with entries in <span class="process-math">\(\Z\)</span>
</div>
<div class="displaymath process-math">
\begin{equation*}
A=\begin{bmatrix}
1 &amp; 6 &amp; 5 &amp; 2 \\
2 &amp; 1 &amp; -1 &amp; 0 \\
3 &amp; 0 &amp; 3 &amp; 0
\end{bmatrix}.
\end{equation*}
</div>
<div class="para">Do row and column operations to put <span class="process-math">\(A\)</span> into its Smith Normal Form:</div>
<div class="displaymath process-math">
\begin{equation*}
S=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 6 &amp; 0 \\\end{bmatrix}.
\end{equation*}
</div>
<div class="para">Conclude that the module presented by <span class="process-math">\(A\)</span> is isomorphic to <span class="process-math">\(\Z/6\text{.}\)</span>
</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\rem\)</span>.</span></h5> <div class="para">A version of the SNF Theorem and its Corollary are valid for PIDs: If <span class="process-math">\(R\)</span> is a PID and <span class="process-math">\(A \in \Mat_{m \times n}(R)\text{,}\)</span> there there exist invertible matrices <span class="process-math">\(P\)</span> and <span class="process-math">\(Q\)</span> such that <span class="process-math">\(PAQ\)</span> has the form <span class="process-math">\(S\)</span> as in the theorem. It follows that every finitely presented module over a PID is direct sum of cyclic ones.</div> <div class="para">For Euclidean domains, <span class="process-math">\(P\)</span> and <span class="process-math">\(Q\)</span> may be taken to be products of elementary matrices, and the Smith normal form can be found algorithmically.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\lem\)</span> - GCD of a Matrix in PID.</span></h5> <div class="para">Suppose <span class="process-math">\(R\)</span> is a PID and <span class="process-math">\(A\)</span> is a matrix with entries in <span class="process-math">\(R\)</span> and <span class="process-math">\(B\)</span> is a matrix obtained from <span class="process-math">\(A\)</span> via elementary column and column operations. Then <span class="process-math">\(\gcd(A) = \gcd(B)\)</span> where the gcd of a matrix is defined to be the gcd of all of its entries.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> - Minor.</span></h5> <div class="para">A <span class="process-math">\(k \times k\)</span> <em class="emphasis">minor</em> of <span class="process-math">\(A\)</span> is the determinant of a <span class="process-math">\(k \times k\)</span> submatrix of <span class="process-math">\(A\text{;}\)</span> more formally, if <span class="process-math">\(A\)</span> is an <span class="process-math">\(m \times n\)</span> matrix, a <span class="process-math">\(k\times k\)</span> minor of <span class="process-math">\(A\)</span> is any element of <span class="process-math">\(R\)</span> given as follows: Choose <span class="process-math">\(1 \leq i_1 &lt; i_2 &lt; \cdots &lt; i_k \leq m\)</span> and <span class="process-math">\(1 \leq j_1 &lt; \cdots &lt; j_k \leq n\text{,}\)</span> let <span class="process-math">\(B = (b_{p,q})\)</span> be the <span class="process-math">\(k \times k\)</span> matrix with <span class="process-math">\(b_{p,q} = a_{i_p, j_q}\text{.}\)</span> Then <span class="process-math">\(\det(B)\)</span> is a minor of <span class="process-math">\(A\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\lem\)</span> - Ideals Generated by Minors.</span></h5> <div class="para">For any commutative ring <span class="process-math">\(R\)</span> and matrix <span class="process-math">\(A \in \Mat_{m \times n}(R)\text{,}\)</span> if <span class="process-math">\(B\)</span> is obtained from <span class="process-math">\(A\)</span> via an elementary column or column operation, then the ideal of <span class="process-math">\(R\)</span> generated by all the <span class="process-math">\(k \times k\)</span> minors of <span class="process-math">\(B\)</span> equals the ideal of <span class="process-math">\(R\)</span> generated by all the <span class="process-math">\(k \times k\)</span> minors of <span class="process-math">\(A\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\thm\)</span> - Smith Normal Form is Unique.</span></h5> <div class="para logical">
<div class="para">Assume <span class="process-math">\(R\)</span> is a PID and <span class="process-math">\(A \in \Mat_{m \times n}(R)\text{.}\)</span> Suppose <span class="process-math">\(S \in \Mat_{m \times n}(R)\)</span> can be obtained from <span class="process-math">\(A\)</span> via a sequence of elementary column and column operations and that <span class="process-math">\(S\)</span> is diagonal with diagonal entries <span class="process-math">\(d_1, d_2, \dots\)</span> such that <span class="process-math">\(d_1 \mid d_2 \mid \cdots\text{.}\)</span> Then</div>
<div class="displaymath process-math">
\begin{equation*}
d_1 = \gcd_1(A), d_2 = \frac{\gcd_2(A)}{\gcd_1(A)}, d_3 = \frac{\gcd_3(A)}{\gcd_2(A)}, \cdots.
\end{equation*}
</div>
<div class="para">In particular, the SNF of a matrix is unique up to associates.</div>
</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para">Recall that for a PID <span class="process-math">\(R\text{,}\)</span> the gcd of any set of elements is defined to be a generatpr of the ideal they generate. So, Lemma  implies that <span class="process-math">\(\gcd_k(A) = \gcd_k(S)\)</span> for all <span class="process-math">\(k\text{.}\)</span> Since <span class="process-math">\(S\)</span> is diagonal, the only non-zero minors of <span class="process-math">\(S\)</span> are those given by indices <span class="process-math">\(1 \leq i_1 &lt; \cdots &lt; i_k \leq m\)</span> and<span class="process-math">\(1 \leq j_1 &lt; \cdots &lt; j_k \leq m\)</span> for which <span class="process-math">\(i_t = j_t\)</span> for all <span class="process-math">\(1 \leq t \leq k\text{,}\)</span> and moreover such a minor is equal to <span class="process-math">\(d_{i_1} \cdots d_{i_k}\text{.}\)</span> Since <span class="process-math">\(d_l \mid d_{l+1}\)</span> for all <span class="process-math">\(l\text{,}\)</span> it follows that <span class="process-math">\(d_{1} \cdots d_k\)</span> divides <span class="process-math">\(d_{i_1} \cdots d_{i_k}\)</span> for all <span class="process-math">\(1 \leq i_1 &lt; \cdots &lt; i_k \leq n\text{.}\)</span> Thus <span class="process-math">\(\gcd_k(S) = d_1 \cdots d_k\text{,}\)</span> for each <span class="process-math">\(k\text{,}\)</span> and hence <span class="process-math">\(d_k = \gcd_k(S)/\gcd_{k-1}(S)\)</span> as claimed.</div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\rem\)</span>.</span></h5> <div class="para">So, another way of finding the SNF of a matrix <span class="process-math">\(A\)</span> with entries in a Euclidean domain is to calculate <span class="process-math">\(\gcd_k(A)\)</span> for all <span class="process-math">\(k\text{.}\)</span> This is not practical except in very special cases.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(A = \begin{bmatrix} 3 &amp; 1 &amp; -4 \\ 2 &amp; -3 &amp; 1 \\ -4 &amp; 6 &amp; -2 \end{bmatrix} \in \Mat_{3 \times 3}(\Z)\text{.}\)</span> Express the <span class="process-math">\(\Z\)</span>-module presented by <span class="process-math">\(A\)</span> as the direct sum of cyclic groups. Justify your answer.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(A = \begin{bmatrix} 2 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 6 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 20 &amp; 0 \end{bmatrix}\)</span> and <span class="process-math">\(B = \begin{bmatrix} 2 &amp; 0 &amp; 0 \\ 0 &amp; 6 &amp; 0 \\ 0 &amp; 0 &amp; 20 \\ 0 &amp; 0 &amp; 0 \end{bmatrix}\text{,}\)</span> regarded as matrices with entries in <span class="process-math">\(\Z\text{.}\)</span> 1. Express the cokernel of <span class="process-math">\(A\)</span> (i.e., <span class="process-math">\(\Z^3/\im(t_A)\)</span>) in elementary divisor form (that is, as a direct sum of cyclic groups each of which is either infinite or of prime power order). 2. Express the cokernel of <span class="process-math">\(B\)</span> in elementary divisor form.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem -.</span></h5> <div class="para logical">
<div class="para">Consider the matrix</div>
<div class="displaymath process-math">
\begin{equation*}
A=\begin{bmatrix}
1 &amp; 6 &amp; 5 &amp; 2 \\
2 &amp; 1 &amp; -1 &amp; 0 \\
3 &amp; 0 &amp; 3 &amp; 0
\end{bmatrix}
\in \M_{3,4}(\Z).
\end{equation*}
</div>
<div class="para">Determine the simplest representative in the isomorphism class of the <span class="process-math">\(\Z\)</span>-module presented by <span class="process-math">\(A\text{.}\)</span>
</div>
</div></section></section><span class="incontext"><a href="sec-snf.html#thm-smith-normal-form" class="internal">in-context</a></span>
</body>
</html>
