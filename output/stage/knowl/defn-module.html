<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<section class="paragraphs"><h4 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> – Module.</span></h4> <div class="para">Let <span class="process-math">\(R\)</span> be a ring (with <span class="process-math">\(1\)</span>). A left <span class="process-math">\(R\)</span>-<span class="process-math">\(\defnn{module}\)</span> is an abelian group <span class="process-math">\((M,+)\)</span> together with a pairing <span class="process-math">\(R \times M \to M\text{,}\)</span> written <span class="process-math">\((r,m) \mapsto rm\text{,}\)</span> such that for all <span class="process-math">\(r,s \in R\)</span> and <span class="process-math">\(m,n \in M\)</span> 1. <span class="process-math">\((r + s)m = rm + sm\text{,}\)</span> 2. <span class="process-math">\((rs)m = r(sm)\text{,}\)</span> 3. <span class="process-math">\(r(m + n) = rm + rn\text{,}\)</span> and 4. <span class="process-math">\(1m = m\text{.}\)</span>
</div> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\rem\)</span>.</span></h5> <div class="para">If <span class="process-math">\(R\)</span> is a commutative ring, then any left <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\)</span> may be regarded as a right <span class="process-math">\(R\)</span>-module by setting <span class="process-math">\(m r = r m\text{.}\)</span> Likewise, any right <span class="process-math">\(R\)</span>-module may be regarded as a left <span class="process-math">\(R\)</span>-module. But for non-commutative rings, left and right modules are not the same: trying to make a left <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\)</span> into a right one by setting <span class="process-math">\(mr = rm\)</span> fails to satisfy the second axiom, since <span class="process-math">\(m(rs) = (rs)m\)</span> and <span class="process-math">\((mr)s = (rm)s = s(rm) = (sr)m\text{,}\)</span> and, unless <span class="process-math">\(rs =sr\text{,}\)</span> we cannot conclude that <span class="process-math">\(m(rs) = (mr)s\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> – Opposite Ring.</span></h5> <div class="para">Given a ring <span class="process-math">\(R\text{,}\)</span> let <span class="process-math">\(R^{op}\text{,}\)</span> the ‘opposite ring’, denote the same set with same rule for <span class="process-math">\(+\text{,}\)</span> but with multiplication redefined as <span class="process-math">\(a \cdot_{op} b := b a\)</span> (where <span class="process-math">\(ba\)</span> on the right is the original multiplication ring). Then <span class="process-math">\(R^{op}\)</span> is also a ring – note that it coincides with <span class="process-math">\(R\)</span> if and only if <span class="process-math">\(R\)</span> is commutative. Given a left <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\text{,}\)</span> show that <span class="process-math">\(M\)</span> is a right <span class="process-math">\(R^{op}\)</span>-module via the rule for scaling given by <span class="process-math">\(m r := rm\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Given a ring <span class="process-math">\(R\text{,}\)</span> let <span class="process-math">\(R^{op}\)</span> denote the “opposite ring’’. This is the same underlying set as <span class="process-math">\(R\)</span> equipped with the same rule for <span class="process-math">\(+\)</span> as <span class="process-math">\(R\text{,}\)</span> but with multiplication rule (which I will write here as <span class="process-math">\(\cdot_{op}\)</span>) redefined to be <span class="process-math">\(a \cdot_{op} b := b a\)</span> (where <span class="process-math">\(ba\)</span> refers to the original multiplication rule for <span class="process-math">\(R\)</span>). Then <span class="process-math">\(R^{op}\)</span> is also a ring — you don’t need to prove that.</div> <div class="para">Given a left <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\text{,}\)</span> prove that <span class="process-math">\(M\)</span> is a right <span class="process-math">\(R^{op}\)</span>-module via the same rule for addition but with the rule for scaling on the right defined to be <span class="process-math">\(m r := rm\)</span> for any <span class="process-math">\(r \in R\)</span> and <span class="process-math">\(m \in M\text{.}\)</span> #### <span class="process-math">\(\lem\)</span> – Arithmetic in Modules Let <span class="process-math">\(R\)</span> be a ring and let <span class="process-math">\(M\)</span> be a (left) <span class="process-math">\(R\)</span>-module. Then for all <span class="process-math">\(r \in R\)</span> and <span class="process-math">\(m \in M\)</span> we have 1. <span class="process-math">\(0_Rm = 0_M\text{,}\)</span> 2. <span class="process-math">\(r 0_M = 0_M\text{,}\)</span> 3. <span class="process-math">\((-1_R)m = -m\text{,}\)</span> and 4. <span class="process-math">\((-r)m = -(rm)\)</span> .</div> <section class="paragraphs"><h6 class="heading"><span class="title"><em class="emphasis">Proof.</em>.</span></h6> <div class="para logical"><ol class="decimal">
<li><div class="para">For the first, <span class="process-math">\(0m = (0+0)m = 0m + 0m\)</span> and hence <span class="process-math">\(0m = 0\text{.}\)</span>
</div></li>
<li><div class="para">For the second, <span class="process-math">\(0_Rm = (0_R + 0_R)m = 0_Rm + 0_Rm\)</span> and hence <span class="process-math">\(0_Rm = 0_M\)</span> since <span class="process-math">\(M\)</span> is an abelian group.</div></li>
<li><div class="para">For the third, <span class="process-math">\(m + (-1)m = 1 m + (-1)m = (1 + (-1))m = (1 - 1)m = 0_Rm = 0_M\)</span> (using the second) and hence <span class="process-math">\((-1)m\)</span> is the additive inverse of <span class="process-math">\(m\text{.}\)</span>
</div></li>
<li><div class="para">Finally, <span class="process-math">\((-r)m = ((-1)r)(m) = (-1)(rm) = -(rm)\)</span> (using the fact that <span class="process-math">\((-1)r = -r\)</span> holds in any ring and the previous result).</div></li>
</ol></div></section></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\ex\)</span> – Modules.</span></h5> <div class="para logical"><ul class="disc">
<li><div class="para">For any ring <span class="process-math">\(R\text{,}\)</span> the trivial module is <span class="process-math">\(0=\{0\}\)</span> with <span class="process-math">\(r0=0\)</span> for any <span class="process-math">\(r\in R\text{.}\)</span>
</div></li>
<li><div class="para">Every ring <span class="process-math">\(R\)</span> is a left module over itself whit the rule for scaling given by the ring multiplication rule. It is also a right module over itself.</div></li>
<li><div class="para">More generally, if <span class="process-math">\(R\)</span> is any ring and <span class="process-math">\(I\)</span> is a left ideal, then <span class="process-math">\(I\)</span> is a left-<span class="process-math">\(R\)</span>-module.</div></li>
<li><div class="para">Let <span class="process-math">\(F\)</span> be a field and <span class="process-math">\(R = \Mat_{n \times n}(F)\)</span> (the ring of <span class="process-math">\(n \times n\)</span> matrices with entries in <span class="process-math">\(F\)</span>). Let <span class="process-math">\(M\)</span> be the collection of column vectors with entries in <span class="process-math">\(F\)</span> having <span class="process-math">\(n\)</span> entries. The usual rules for adding column vectors and multiplying column vectors on the left by matrices make <span class="process-math">\(M\)</span> into a left <span class="process-math">\(R\)</span>-module. Likewise if <span class="process-math">\(N\)</span> is the collection of all row vector with <span class="process-math">\(n\)</span> entries in <span class="process-math">\(F\text{,}\)</span> the <span class="process-math">\(N\)</span> is a right <span class="process-math">\(R\)</span>-module via addition and matrix multiplication.</div></li>
</ul></div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\ex\)</span> – Standard Free Module.</span></h5> <div class="para logical">
<div class="para">For a non-negative integer <span class="process-math">\(n\text{,}\)</span> the “standard’’ free (left) <span class="process-math">\(R\)</span>-module of rank <span class="process-math">\(n\)</span> is the set</div>
<div class="displaymath process-math">
\begin{equation*}
R^n=\left\{\begin{bmatrix} r_1\\ \vdots \\r_n \end{bmatrix} \mid r_i\in R, 1\leq i\leq n\right\}
\end{equation*}
</div>
<div class="para">equipped with the operations</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{bmatrix} r_1\\ \vdots\\r_n \end{bmatrix} +\begin{bmatrix} r'_1\\ \vdots\\r'_n \end{bmatrix} =\begin{bmatrix} r_1+r'_1\\ \vdots\\r_n +r'_n\end{bmatrix} \text{ and }
r\begin{bmatrix} r_1\\ \vdots\\r_n \end{bmatrix}=\begin{bmatrix} rr_1\\ \vdots\\ rr_n \end{bmatrix}. 
\end{equation*}
</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> – Vector Space (Module).</span></h5> <div class="para">Let <span class="process-math">\(F\)</span> be a field. An <span class="process-math">\(F\)</span>-<span class="process-math">\(\defnn{vector space}\)</span> is a (left) <span class="process-math">\(F\)</span>-module.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\prop\)</span> – Abelian Groups are <span class="process-math">\(\Z\)</span>-modules.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(M\)</span> be an abelian group under <span class="process-math">\(+\text{.}\)</span> Then <span class="process-math">\(M\)</span> becomes a <span class="process-math">\(\Z\)</span>-module upon defining the rule for scaling to be <span class="process-math">\(nm :=\)</span>
</div>
<div class="displaymath process-math">
\begin{equation*}
0 \textrm{ if } n=0,
\end{equation*}
</div>
<div class="displaymath process-math">
\begin{equation*}
\overbrace{m + \cdots + m}^{\text{n times}},  \text{ if } n &gt; 0, \text{ and }
\end{equation*}
</div>
<div class="displaymath process-math">
\begin{equation*}
(\overbrace{m + \cdots + m}^{\text{|n| times}}), \text{ if }n &lt; 0,
\end{equation*}
</div>
<div class="para">for any <span class="process-math">\(n \in \Z\)</span> and <span class="process-math">\(m \in M\text{.}\)</span>
</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para">Let <span class="process-math">\(n\)</span> be a positive integer and recall that <span class="process-math">\(\Z/n\)</span> denotes the ring of integers modulo <span class="process-math">\(n\)</span> (whose elements I will write as <span class="process-math">\(\ov{0}, \ov1, \cdots, \ov{n-1}\)</span>). 1. Show that if <span class="process-math">\(M\)</span> is any abelian group (under the operation <span class="process-math">\(+\)</span>) such that <span class="process-math">\(nx = 0\)</span> for all <span class="process-math">\(x \in M\)</span> (where <span class="process-math">\(nx := \overbrace{x + x + \cdots + x}^{\text{n times}}\)</span>), then the pairing <span class="process-math">\(\Z/n \times M \to M\)</span> given <span class="process-math">\((\ov{j}, m) \mapsto jm\)</span> makes <span class="process-math">\(M\)</span> into a <span class="process-math">\(\Z/n\)</span>-module. (Be sure to check this pairing is well-defined.) 2. Conversely, show that if <span class="process-math">\(M\)</span> is a <span class="process-math">\(\Z/n\)</span>-module, then the underlying abelian group <span class="process-math">\((M, +)\)</span> has the property that <span class="process-math">\(nx = 0\)</span> for all <span class="process-math">\(x \in M\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\prop\)</span> – Restriction of Scalars.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(\phi: R \to S\)</span> be a ring homomorphism. Any left <span class="process-math">\(S\)</span>-module <span class="process-math">\(M\)</span> may be regarded via <em class="emphasis">restriction of scalars</em> as a left <span class="process-math">\(R\)</span>-module with the following structure: - the rule for addition <span class="process-math">\(+\)</span> on <span class="process-math">\(M\)</span> is the same as in the original structure and - the rule for scaling by elements of <span class="process-math">\(R\)</span> is</div>
<div class="displaymath process-math">
\begin{equation*}
r \cdot m := \phi(r)m \text{ for any }r \in R \text{ and }m\in M.
\end{equation*}
</div>
<div class="para">###### <em class="emphasis">Proof.</em> Let <span class="process-math">\(x,y \in R\)</span> and <span class="process-math">\(m,n \in M\text{.}\)</span> One checks that the properties in the definition of module hold for the given action using properties of ring homomorphisms. In detail,</div>
<div class="displaymath process-math">
\begin{equation*}
(x+y)m =\phi(x + y)m= (\phi(x)+\phi(y))m=\phi(x)m + \phi(y)m=xm+ym,
\end{equation*}
</div>
<div class="para">since <span class="process-math">\(\phi\)</span> preserves addition,</div>
<div class="displaymath process-math">
\begin{equation*}
x(ym)=\phi(x) (\phi(y)m) = (\phi(x) \phi(y)) m = \phi(xy) m = (xy) m,
\end{equation*}
</div>
<div class="para">since <span class="process-math">\(\phi\)</span> preserves multiplication, and</div>
<div class="displaymath process-math">
\begin{equation*}
1 \cdot m = \phi(1) m = 1_S m = m
\end{equation*}
</div>
<div class="para">since <span class="process-math">\(\phi\)</span> preserves multiplicative identities. This gives three of the axioms. The final also holds:</div>
<div class="displaymath process-math">
\begin{equation*}
x(m + n) = \phi(x) (m+n) = \phi(x)m + \phi(x)n = xm + xn.
\end{equation*}
</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> – Complex Vector Spaces are Real Vector Spaces.</span></h5> <div class="para">For example, since <span class="process-math">\(\R\)</span> is a subring of <span class="process-math">\(\C\text{,}\)</span> every complex vector space may be regarded as a real vector space, by restriction of scalars from <span class="process-math">\(\C\)</span> to <span class="process-math">\(\R\text{.}\)</span> Likewise, any real vector space may be regarded as a rational vector space. Etc.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> – Homomorphisms and Restriction of Scalars.</span></h5> <div class="para">If <span class="process-math">\(S\)</span> and <span class="process-math">\(R\)</span> are rings and <span class="process-math">\(\phi: S \to R\)</span> is a ring homomorphism, then since <span class="process-math">\(S\)</span> is a left <span class="process-math">\(S\)</span>-module, it is also a left <span class="process-math">\(R\)</span>-module via restriction of scalars. Note that the rule for scaling given by <span class="process-math">\(r s := \phi(r) s\text{.}\)</span>
</div> <div class="para">As a special case of this, if <span class="process-math">\(S\)</span> is a subring of a ring <span class="process-math">\(R\)</span> then <span class="process-math">\(R\)</span> is an <span class="process-math">\(S\)</span>-module (restriction of scalars along the inclusion map).</div> <div class="para">For instance, <span class="process-math">\(R[x_1,\ldots,x_n]\)</span> is a left <span class="process-math">\(R\)</span>-module for any <span class="process-math">\(n\geq 0\)</span> via the evident injective ring homomorphism <span class="process-math">\(R \into R[x_1, \ldots, x_n]\text{.}\)</span>
</div> <div class="para">Also, <span class="process-math">\(\Mat_{n \times n}(R)\)</span> is a left <span class="process-math">\(R\)</span>-module for <span class="process-math">\(n\geq 1\)</span> given by the ring map <span class="process-math">\(R \to \Mat_{n \times n}(R)\)</span> sending <span class="process-math">\(r\)</span> to <span class="process-math">\(r \cdot I_n\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> – <span class="process-math">\(R/I\)</span>-Module is an <span class="process-math">\(R\)</span>-Module.</span></h5> <div class="para">If <span class="process-math">\(I\)</span> is a (two-sided) ideal of a ring <span class="process-math">\(R\)</span> then applying restriction of scalars along the quotient homomorphism[^1] <span class="process-math">\(q:R\to R/I\)</span> gives that any left <span class="process-math">\(R/I\)</span>-module is also a left <span class="process-math">\(R\)</span>-module.</div> <div class="para">In particular, applying this to the <span class="process-math">\(R/I\)</span>-module <span class="process-math">\(R/I\)</span> gives that <span class="process-math">\(R/I\)</span> is a left <span class="process-math">\(R\)</span>-module. The rule for scaling is <span class="process-math">\(r \cdot (r' + I) = rr' + I\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> – Submodule.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring and let <span class="process-math">\(M\)</span> be a left <span class="process-math">\(R\)</span>-module. An <em class="emphasis"><span class="process-math">\(R\)</span>-<span class="process-math">\(\defnn{submodule}\)</span></em> of <span class="process-math">\(M\)</span> is a subset <span class="process-math">\(N \subseteq M\)</span> such that 1. <span class="process-math">\(N\)</span> is a subgroup of <span class="process-math">\(M\)</span> under <span class="process-math">\(+\)</span> (so, we have <span class="process-math">\(0 \in N\text{,}\)</span> if <span class="process-math">\(n \in N\)</span> then <span class="process-math">\(-n \in N\text{,}\)</span> and if <span class="process-math">\(n_1, n_2 \in N\)</span> then <span class="process-math">\(n_1 + n_2 \in N\)</span>), and 2. <span class="process-math">\(rn \in N\)</span> for all <span class="process-math">\(r \in R\)</span> and <span class="process-math">\(n \in N\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(M\)</span> be an <span class="process-math">\(R\)</span>-module and <span class="process-math">\(I\)</span> be an ideal in <span class="process-math">\(R\text{.}\)</span> Show that the set</div>
<div class="displaymath process-math">
\begin{equation*}
N = \{ m \in M \mid am = 0 \textrm{ for all } a \in I \}
\end{equation*}
</div>
<div class="para">is an <span class="process-math">\(R\)</span>-submodule of <span class="process-math">\(M\text{.}\)</span>
</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> – <span class="process-math">\(R\)</span>-Module Homomorphism.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring and let <span class="process-math">\(M\)</span> and <span class="process-math">\(N\)</span> be <span class="process-math">\(R\)</span>-modules. An <span class="process-math">\(R\)</span>-module <em class="emphasis"><span class="process-math">\(\defnn{homomorphism}\)</span></em> from <span class="process-math">\(M\)</span> to <span class="process-math">\(N,\)</span> sometimes called an <span class="process-math">\(R\)</span>-<em class="emphasis"><span class="process-math">\(\defnn{map}\)</span></em>, is a function <span class="process-math">\(h: M \to N\)</span> such that for all <span class="process-math">\(r \in R\)</span> and <span class="process-math">\(m,n \in M\)</span> we have 1. <span class="process-math">\(h(m+n)=h(m)+h(n)\text{,}\)</span> i.e. <span class="process-math">\(h\)</span> is an additive group homomorphism, and 2. <span class="process-math">\(h(rm) = rh(m)\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> – Linear Transformation (Module).</span></h5> <div class="para">Let <span class="process-math">\(F\)</span> be a field and let <span class="process-math">\(M\)</span> and <span class="process-math">\(N\)</span> be vector spaces over <span class="process-math">\(F\text{.}\)</span> A <em class="emphasis"><span class="process-math">\(\defnn{linear transformation}\)</span></em> from <span class="process-math">\(M\)</span> to <span class="process-math">\(N\)</span> is an <span class="process-math">\(F\)</span>-module homomorphism <span class="process-math">\(h:M \to N\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\defn\)</span> – <span class="process-math">\(R\)</span>-Module Isomorphism.</span></h5> <div class="para">An <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(h: M \to N\)</span> is an <span class="process-math">\(R\)</span>-module <em class="emphasis"><span class="process-math">\(\defnn{isomorphism}\)</span></em> if there is another <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(g: N \to M\)</span> such that <span class="process-math">\(h \circ g = \id_M\)</span> and <span class="process-math">\(g \circ h = \id_N\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\lem\)</span> – Module Isomorphisms and Bijections.</span></h5> <div class="para">Given a ring <span class="process-math">\(R\text{,}\)</span> <span class="process-math">\(R\)</span>-modules <span class="process-math">\(M\)</span> and <span class="process-math">\(N\text{,}\)</span> and a <span class="process-math">\(R\)</span>-module homomorphism <span class="process-math">\(f: M \to N\text{,}\)</span> <span class="process-math">\(f\)</span> is an <span class="process-math">\(R\)</span>-module isomorphism if and only if <span class="process-math">\(f\)</span> is a bijection.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\exe\)</span> – Submodules are Ideals.</span></h5> <div class="para">A subset <span class="process-math">\(I\)</span> of a ring <span class="process-math">\(R\)</span> is a left submodule of <span class="process-math">\(R\)</span> if and only if it is a (left) ideal.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title"><span class="process-math">\(\lem\)</span> – Kernels and Images of Homomorphisms are Submodules.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a ring and let <span class="process-math">\(h: M \to M'\)</span> be an <span class="process-math">\(R\)</span>-module homomorphism. Then <span class="process-math">\(\ker(h) := \{m \in M \mid h(m) = 0_N\}\)</span> is an <span class="process-math">\(R\)</span>-submodule of <span class="process-math">\(M\)</span> and <span class="process-math">\(\im(h)\)</span> is an <span class="process-math">\(R\)</span>-submodule of <span class="process-math">\(M'\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(F\)</span> be any field and <span class="process-math">\(R\)</span> the set of infinte-by-infinite, column-finite matrices. That is, <span class="process-math">\(R\)</span> consists of arrays <span class="process-math">\(A = (a_{i,j})_{i \in \N, j \in \N}\text{,}\)</span> where <span class="process-math">\(\N = \{1, 2, \dots \}\)</span> and <span class="process-math">\(a_{i,j} \in R\)</span> for all <span class="process-math">\(i,j\text{,}\)</span> such that for each <span class="process-math">\(j\text{,}\)</span> there exists an <span class="process-math">\(I\)</span> (depending on <span class="process-math">\(j\)</span>) such that <span class="process-math">\(a_{i,j} = 0\)</span> for all <span class="process-math">\(i \geq I\text{.}\)</span> That is, <span class="process-math">\(R\)</span> consists of elements of the form</div>
<div class="displaymath process-math">
\begin{equation*}
A = \begin{bmatrix}
a_{1,1} &amp; a_{1,2} &amp; \cdots \\
a_{2,1} &amp; a_{2,2} &amp;  \cdots \\
\vdots &amp; \vdots &amp;  \\
\end{bmatrix}
\end{equation*}
</div>
<div class="para">such that each column has only a finite number of non-zero entries (but, importantly, there is no uniform bound on the number of non-zero entries a column may have). It is not difficult to see that <span class="process-math">\(R\)</span> is a ring under the usual rules for adding and multiplying matrices: Given <span class="process-math">\(A\)</span> as above and <span class="process-math">\(B=(b_{i,j})_{i \in \N, j \in \N}\)</span> we define</div>
<div class="displaymath process-math">
\begin{equation*}
\text{the $(i,j)$ entry of $A + B$ to be $a_{i,j} + b_{i,j}$}
\end{equation*}
</div>
<div class="para">and</div>
<div class="displaymath process-math">
\begin{equation*}
\text{the $(i,j)$ entry of $AB$ to be $\sum_l a_{i,l} b_{l , j}$}.
\end{equation*}
</div>
<div class="para">Note that the latter is a finite sum since, given <span class="process-math">\(j\text{,}\)</span>there is an <span class="process-math">\(L\)</span> such that <span class="process-math">\(b_{l,j} = 0\)</span> for all <span class="process-math">\(l \geq L\text{.}\)</span> Moreover, <span class="process-math">\(AB\)</span> is column-finite since, for each such <span class="process-math">\(j\text{,}\)</span> each of the columns <span class="process-math">\(1, \dots, L-1\)</span> of <span class="process-math">\(A\)</span> has only a finite number of non-zero elements. The multiplicative identity is the infinite identity matrix. You need not prove any of this.</div>
</div> <div class="para">Do prove that <span class="process-math">\(R \cong R^2\)</span> as left <span class="process-math">\(R\)</span>-modules. {} Think about splitting up an element of <span class="process-math">\(R\)</span> into its even and odd columns.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para">Given a homomorphism of <span class="process-math">\(R\)</span>-modules <span class="process-math">\(f\!: M \to N\text{,}\)</span> show that <span class="process-math">\(\ker(f)\)</span> is an <span class="process-math">\(R\)</span>-submodule of <span class="process-math">\(M\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para">Show that for every nonzero integers <span class="process-math">\(m\)</span> and <span class="process-math">\(n\)</span> there is a <span class="process-math">\(\Z\)</span>-module isomorphism <span class="process-math">\(\Hom_\Z(\Z/(n),\Z/(m)) \cong \Z / (\gcd(m,n))\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(R\)</span> be a commutative ring. Given an <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\text{,}\)</span> its annihilator is the ideal</div>
<div class="displaymath process-math">
\begin{equation*}
\ann(M) := \{ a \in R \mid am = 0 \textrm{ for all } m \in M \}.
\end{equation*}
</div>
<div class="para">Show that if there is an isomorphism of <span class="process-math">\(R\)</span>-modules <span class="process-math">\(M \cong N\text{,}\)</span> then <span class="process-math">\(\ann(M) = \ann(N)\text{.}\)</span>
</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem –.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a commutative ring with <span class="process-math">\(1 \neq 0\text{.}\)</span> An <span class="process-math">\(R\)</span>-module <span class="process-math">\(M\)</span> is simple if it has no nontrivial submodules. Show that <span class="process-math">\(M \neq 0\)</span> is simple if and only if there exists a maximal ideal <span class="process-math">\(\fm\)</span> of <span class="process-math">\(R\)</span> such that <span class="process-math">\(M \cong R/\fm\text{.}\)</span>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem 8 #unfinished.</span></h5> <div class="para">Let N be a submodule of an R-module M. Using Zorn’s Lemma, prove that there is a submodule N′ such that 1. <span class="process-math">\(N\cap N' = (0)\text{,}\)</span> and 2. <span class="process-math">\(N''\cap(N + N')\neq(0)\)</span> for every non-zero submodule N′′ of M.</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem 5 #unfinished.</span></h5> <div class="para logical">
<div class="para">Let <span class="process-math">\(A\)</span> be a <span class="process-math">\(\Z\)</span>–module and let <span class="process-math">\(n\)</span> be any integer. Show that there is a <span class="process-math">\(\Z\)</span>-module isomorphism</div>
<div class="displaymath process-math">
\begin{equation*}
\Hom_\Z(\Z/n\Z, A)\cong A_n, \text{ where }A_n = \{a \in A | na = 0\}
\end{equation*}
</div>
<div class="para">is a submodule of <span class="process-math">\(A\text{.}\)</span> (Note: You may use the fact that <span class="process-math">\(A_n\)</span> is a <span class="process-math">\(\Z\)</span>–module without proof.)</div>
</div></section> <section class="paragraphs"><h5 class="heading"><span class="title">Problem 5 #unfinished.</span></h5> <div class="para">Let <span class="process-math">\(R\)</span> be a non-zero, unital ring, and let <span class="process-math">\(R^m\)</span> and <span class="process-math">\(R^n\)</span> be the standard free left <span class="process-math">\(R\)</span>-modules of finite rank <span class="process-math">\(m\)</span> and <span class="process-math">\(n\text{.}\)</span> Assume there is an isomorphism of <span class="process-math">\(R\)</span>-modules <span class="process-math">\(R^m \cong R^n.\)</span>
</div> <div class="para logical"><ol class="decimal">
<li><div class="para">Prove that if <span class="process-math">\(R\)</span> is commutative then <span class="process-math">\(m = n\text{.}\)</span> You may assume without justification that this holds in the special case when <span class="process-math">\(R\)</span> is a field.</div></li>
<li><div class="para">Show, by example, than <span class="process-math">\(m\)</span> need not equal <span class="process-math">\(n\)</span> if <span class="process-math">\(R\)</span> is not assumed to be commutative.</div></li>
</ol></div></section></section><span class="incontext"><a href="sec-defmod.html#defn-module" class="internal">in-context</a></span>
</body>
</html>
